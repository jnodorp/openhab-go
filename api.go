// Package openhab provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openhab

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for ConfigDescriptionParameterType.
const (
	ConfigDescriptionParameterTypeBOOLEAN ConfigDescriptionParameterType = "BOOLEAN"
	ConfigDescriptionParameterTypeDECIMAL ConfigDescriptionParameterType = "DECIMAL"
	ConfigDescriptionParameterTypeINTEGER ConfigDescriptionParameterType = "INTEGER"
	ConfigDescriptionParameterTypeTEXT    ConfigDescriptionParameterType = "TEXT"
)

// Defines values for ConfigDescriptionParameterDTOType.
const (
	ConfigDescriptionParameterDTOTypeBOOLEAN ConfigDescriptionParameterDTOType = "BOOLEAN"
	ConfigDescriptionParameterDTOTypeDECIMAL ConfigDescriptionParameterDTOType = "DECIMAL"
	ConfigDescriptionParameterDTOTypeINTEGER ConfigDescriptionParameterDTOType = "INTEGER"
	ConfigDescriptionParameterDTOTypeTEXT    ConfigDescriptionParameterDTOType = "TEXT"
)

// Defines values for ConfigStatusMessageType.
const (
	ERROR       ConfigStatusMessageType = "ERROR"
	INFORMATION ConfigStatusMessageType = "INFORMATION"
	PENDING     ConfigStatusMessageType = "PENDING"
	WARNING     ConfigStatusMessageType = "WARNING"
)

// Defines values for DiscoveryResultDTOFlag.
const (
	IGNORED DiscoveryResultDTOFlag = "IGNORED"
	NEW     DiscoveryResultDTOFlag = "NEW"
)

// Defines values for EnrichedRuleDTOVisibility.
const (
	EnrichedRuleDTOVisibilityEXPERT  EnrichedRuleDTOVisibility = "EXPERT"
	EnrichedRuleDTOVisibilityHIDDEN  EnrichedRuleDTOVisibility = "HIDDEN"
	EnrichedRuleDTOVisibilityVISIBLE EnrichedRuleDTOVisibility = "VISIBLE"
)

// Defines values for IconSetFormats.
const (
	PNG IconSetFormats = "PNG"
	SVG IconSetFormats = "SVG"
)

// Defines values for ModuleTypeDTOVisibility.
const (
	ModuleTypeDTOVisibilityEXPERT  ModuleTypeDTOVisibility = "EXPERT"
	ModuleTypeDTOVisibilityHIDDEN  ModuleTypeDTOVisibility = "HIDDEN"
	ModuleTypeDTOVisibilityVISIBLE ModuleTypeDTOVisibility = "VISIBLE"
)

// Defines values for RuleVisibility.
const (
	RuleVisibilityEXPERT  RuleVisibility = "EXPERT"
	RuleVisibilityHIDDEN  RuleVisibility = "HIDDEN"
	RuleVisibilityVISIBLE RuleVisibility = "VISIBLE"
)

// Defines values for RuleDTOVisibility.
const (
	RuleDTOVisibilityEXPERT  RuleDTOVisibility = "EXPERT"
	RuleDTOVisibilityHIDDEN  RuleDTOVisibility = "HIDDEN"
	RuleDTOVisibilityVISIBLE RuleDTOVisibility = "VISIBLE"
)

// Defines values for RuleStatusInfoStatus.
const (
	RuleStatusInfoStatusIDLE          RuleStatusInfoStatus = "IDLE"
	RuleStatusInfoStatusINITIALIZING  RuleStatusInfoStatus = "INITIALIZING"
	RuleStatusInfoStatusRUNNING       RuleStatusInfoStatus = "RUNNING"
	RuleStatusInfoStatusUNINITIALIZED RuleStatusInfoStatus = "UNINITIALIZED"
)

// Defines values for RuleStatusInfoStatusDetail.
const (
	RuleStatusInfoStatusDetailCONFIGURATIONERROR       RuleStatusInfoStatusDetail = "CONFIGURATION_ERROR"
	RuleStatusInfoStatusDetailDISABLED                 RuleStatusInfoStatusDetail = "DISABLED"
	RuleStatusInfoStatusDetailHANDLERINITIALIZINGERROR RuleStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"
	RuleStatusInfoStatusDetailHANDLERMISSINGERROR      RuleStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"
	RuleStatusInfoStatusDetailINVALIDRULE              RuleStatusInfoStatusDetail = "INVALID_RULE"
	RuleStatusInfoStatusDetailNONE                     RuleStatusInfoStatusDetail = "NONE"
	RuleStatusInfoStatusDetailTEMPLATEMISSINGERROR     RuleStatusInfoStatusDetail = "TEMPLATE_MISSING_ERROR"
)

// Defines values for TemplateVisibility.
const (
	EXPERT  TemplateVisibility = "EXPERT"
	HIDDEN  TemplateVisibility = "HIDDEN"
	VISIBLE TemplateVisibility = "VISIBLE"
)

// Defines values for ThingStatusInfoStatus.
const (
	ThingStatusInfoStatusINITIALIZING  ThingStatusInfoStatus = "INITIALIZING"
	ThingStatusInfoStatusOFFLINE       ThingStatusInfoStatus = "OFFLINE"
	ThingStatusInfoStatusONLINE        ThingStatusInfoStatus = "ONLINE"
	ThingStatusInfoStatusREMOVED       ThingStatusInfoStatus = "REMOVED"
	ThingStatusInfoStatusREMOVING      ThingStatusInfoStatus = "REMOVING"
	ThingStatusInfoStatusUNINITIALIZED ThingStatusInfoStatus = "UNINITIALIZED"
	ThingStatusInfoStatusUNKNOWN       ThingStatusInfoStatus = "UNKNOWN"
)

// Defines values for ThingStatusInfoStatusDetail.
const (
	ThingStatusInfoStatusDetailBRIDGEOFFLINE               ThingStatusInfoStatusDetail = "BRIDGE_OFFLINE"
	ThingStatusInfoStatusDetailBRIDGEUNINITIALIZED         ThingStatusInfoStatusDetail = "BRIDGE_UNINITIALIZED"
	ThingStatusInfoStatusDetailCOMMUNICATIONERROR          ThingStatusInfoStatusDetail = "COMMUNICATION_ERROR"
	ThingStatusInfoStatusDetailCONFIGURATIONERROR          ThingStatusInfoStatusDetail = "CONFIGURATION_ERROR"
	ThingStatusInfoStatusDetailCONFIGURATIONPENDING        ThingStatusInfoStatusDetail = "CONFIGURATION_PENDING"
	ThingStatusInfoStatusDetailDISABLED                    ThingStatusInfoStatusDetail = "DISABLED"
	ThingStatusInfoStatusDetailDUTYCYCLE                   ThingStatusInfoStatusDetail = "DUTY_CYCLE"
	ThingStatusInfoStatusDetailFIRMWAREUPDATING            ThingStatusInfoStatusDetail = "FIRMWARE_UPDATING"
	ThingStatusInfoStatusDetailGONE                        ThingStatusInfoStatusDetail = "GONE"
	ThingStatusInfoStatusDetailHANDLERCONFIGURATIONPENDING ThingStatusInfoStatusDetail = "HANDLER_CONFIGURATION_PENDING"
	ThingStatusInfoStatusDetailHANDLERINITIALIZINGERROR    ThingStatusInfoStatusDetail = "HANDLER_INITIALIZING_ERROR"
	ThingStatusInfoStatusDetailHANDLERMISSINGERROR         ThingStatusInfoStatusDetail = "HANDLER_MISSING_ERROR"
	ThingStatusInfoStatusDetailHANDLERREGISTERINGERROR     ThingStatusInfoStatusDetail = "HANDLER_REGISTERING_ERROR"
	ThingStatusInfoStatusDetailNONE                        ThingStatusInfoStatusDetail = "NONE"
	ThingStatusInfoStatusDetailNOTYETREADY                 ThingStatusInfoStatusDetail = "NOT_YET_READY"
)

// Action defines model for Action.
// +kubebuilder:object:generate=true
type Action struct {
	Configuration *Configuration     `json:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty"`
	Id            *string            `json:"id,omitempty"`
	Inputs        *map[string]string `json:"inputs,omitempty"`
	Label         *string            `json:"label,omitempty"`
	TypeUID       *string            `json:"typeUID,omitempty"`
}

// ActionDTO defines model for ActionDTO.
// +kubebuilder:object:generate=true
type ActionDTO struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage    `json:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty"`
	Id            *string            `json:"id,omitempty"`
	Inputs        *map[string]string `json:"inputs,omitempty"`
	Label         *string            `json:"label,omitempty"`
	Type          *string            `json:"type,omitempty"`
}

// Addon defines model for Addon.
// +kubebuilder:object:generate=true
type Addon struct {
	Author               *string         `json:"author,omitempty"`
	BackgroundColor      *string         `json:"backgroundColor,omitempty"`
	Compatible           *bool           `json:"compatible,omitempty"`
	ConfigDescriptionURI *string         `json:"configDescriptionURI,omitempty"`
	Connection           *string         `json:"connection,omitempty"`
	ContentType          *string         `json:"contentType,omitempty"`
	Countries            *[]string       `json:"countries,omitempty"`
	Description          *string         `json:"description,omitempty"`
	DetailedDescription  *string         `json:"detailedDescription,omitempty"`
	Id                   *string         `json:"id,omitempty"`
	ImageLink            *string         `json:"imageLink,omitempty"`
	Installed            *bool           `json:"installed,omitempty"`
	Keywords             *string         `json:"keywords,omitempty"`
	Label                *string         `json:"label,omitempty"`
	License              *string         `json:"license,omitempty"`
	Link                 *string         `json:"link,omitempty"`
	LoggerPackages       *[]string       `json:"loggerPackages,omitempty"`
	Maturity             *string         `json:"maturity,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Properties           json.RawMessage `json:"properties,omitempty"`
	Type                 *string         `json:"type,omitempty"`
	Uid                  *string         `json:"uid,omitempty"`
	VerifiedAuthor       *bool           `json:"verifiedAuthor,omitempty"`
	Version              *string         `json:"version,omitempty"`
}

// AddonType defines model for AddonType.
// +kubebuilder:object:generate=true
type AddonType struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSinkDTO defines model for AudioSinkDTO.
// +kubebuilder:object:generate=true
type AudioSinkDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// AudioSourceDTO defines model for AudioSourceDTO.
// +kubebuilder:object:generate=true
type AudioSourceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
}

// ChannelDTO defines model for ChannelDTO.
// +kubebuilder:object:generate=true
type ChannelDTO struct {
	AutoUpdatePolicy *string            `json:"autoUpdatePolicy,omitempty"`
	ChannelTypeUID   *string            `json:"channelTypeUID,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration    json.RawMessage    `json:"configuration,omitempty"`
	DefaultTags      *[]string          `json:"defaultTags,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Id               *string            `json:"id,omitempty"`
	ItemType         *string            `json:"itemType,omitempty"`
	Kind             *string            `json:"kind,omitempty"`
	Label            *string            `json:"label,omitempty"`
	Properties       *map[string]string `json:"properties,omitempty"`
	Uid              *string            `json:"uid,omitempty"`
}

// ChannelDefinitionDTO defines model for ChannelDefinitionDTO.
// +kubebuilder:object:generate=true
type ChannelDefinitionDTO struct {
	Advanced         *bool              `json:"advanced,omitempty"`
	Category         *string            `json:"category,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Id               *string            `json:"id,omitempty"`
	Label            *string            `json:"label,omitempty"`
	Properties       *map[string]string `json:"properties,omitempty"`
	StateDescription *StateDescription  `json:"stateDescription,omitempty"`
	Tags             *[]string          `json:"tags,omitempty"`
	TypeUID          *string            `json:"typeUID,omitempty"`
}

// ChannelGroupDefinitionDTO defines model for ChannelGroupDefinitionDTO.
// +kubebuilder:object:generate=true
type ChannelGroupDefinitionDTO struct {
	Channels    *[]ChannelDefinitionDTO `json:"channels,omitempty"`
	Description *string                 `json:"description,omitempty"`
	Id          *string                 `json:"id,omitempty"`
	Label       *string                 `json:"label,omitempty"`
}

// ChannelTypeDTO defines model for ChannelTypeDTO.
// +kubebuilder:object:generate=true
type ChannelTypeDTO struct {
	UID                *string                               `json:"UID,omitempty"`
	Advanced           *bool                                 `json:"advanced,omitempty"`
	Category           *string                               `json:"category,omitempty"`
	CommandDescription *CommandDescription                   `json:"commandDescription,omitempty"`
	Description        *string                               `json:"description,omitempty"`
	ItemType           *string                               `json:"itemType,omitempty"`
	Kind               *string                               `json:"kind,omitempty"`
	Label              *string                               `json:"label,omitempty"`
	ParameterGroups    *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters         *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	StateDescription   *StateDescription                     `json:"stateDescription,omitempty"`
	Tags               *[]string                             `json:"tags,omitempty"`
	UnitHint           *string                               `json:"unitHint,omitempty"`
}

// CommandDescription defines model for CommandDescription.
// +kubebuilder:object:generate=true
type CommandDescription struct {
	CommandOptions *[]CommandOption `json:"commandOptions,omitempty"`
}

// CommandOption defines model for CommandOption.
// +kubebuilder:object:generate=true
type CommandOption struct {
	Command *string `json:"command,omitempty"`
	Label   *string `json:"label,omitempty"`
}

// Condition defines model for Condition.
// +kubebuilder:object:generate=true
type Condition struct {
	Configuration *Configuration     `json:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty"`
	Id            *string            `json:"id,omitempty"`
	Inputs        *map[string]string `json:"inputs,omitempty"`
	Label         *string            `json:"label,omitempty"`
	TypeUID       *string            `json:"typeUID,omitempty"`
}

// ConditionDTO defines model for ConditionDTO.
// +kubebuilder:object:generate=true
type ConditionDTO struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage    `json:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty"`
	Id            *string            `json:"id,omitempty"`
	Inputs        *map[string]string `json:"inputs,omitempty"`
	Label         *string            `json:"label,omitempty"`
	Type          *string            `json:"type,omitempty"`
}

// ConfigDescriptionDTO defines model for ConfigDescriptionDTO.
// +kubebuilder:object:generate=true
type ConfigDescriptionDTO struct {
	ParameterGroups *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Parameters      *[]ConfigDescriptionParameterDTO      `json:"parameters,omitempty"`
	Uri             *string                               `json:"uri,omitempty"`
}

// ConfigDescriptionParameter defines model for ConfigDescriptionParameter.
// +kubebuilder:object:generate=true
type ConfigDescriptionParameter struct {
	Advanced       *bool                           `json:"advanced,omitempty"`
	Context        *string                         `json:"context,omitempty"`
	Default        *string                         `json:"default,omitempty"`
	Description    *string                         `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteria               `json:"filterCriteria,omitempty"`
	GroupName      *string                         `json:"groupName,omitempty"`
	Label          *string                         `json:"label,omitempty"`
	LimitToOptions *bool                           `json:"limitToOptions,omitempty"`
	Maximum        *float32                        `json:"maximum,omitempty"`
	Minimum        *float32                        `json:"minimum,omitempty"`
	Multiple       *bool                           `json:"multiple,omitempty"`
	MultipleLimit  *int32                          `json:"multipleLimit,omitempty"`
	Name           *string                         `json:"name,omitempty"`
	Options        *[]ParameterOption              `json:"options,omitempty"`
	Pattern        *string                         `json:"pattern,omitempty"`
	ReadOnly       *bool                           `json:"readOnly,omitempty"`
	Required       *bool                           `json:"required,omitempty"`
	StepSize       *float32                        `json:"stepSize,omitempty"`
	Type           *ConfigDescriptionParameterType `json:"type,omitempty"`
	Unit           *string                         `json:"unit,omitempty"`
	UnitLabel      *string                         `json:"unitLabel,omitempty"`
	Verifyable     *bool                           `json:"verifyable,omitempty"`
}

// ConfigDescriptionParameterType defines model for ConfigDescriptionParameter.Type.
// +kubebuilder:object:generate=true
type ConfigDescriptionParameterType string

// ConfigDescriptionParameterDTO defines model for ConfigDescriptionParameterDTO.
// +kubebuilder:object:generate=true
type ConfigDescriptionParameterDTO struct {
	Advanced       *bool                              `json:"advanced,omitempty"`
	Context        *string                            `json:"context,omitempty"`
	DefaultValue   *string                            `json:"defaultValue,omitempty"`
	Description    *string                            `json:"description,omitempty"`
	FilterCriteria *[]FilterCriteriaDTO               `json:"filterCriteria,omitempty"`
	GroupName      *string                            `json:"groupName,omitempty"`
	Label          *string                            `json:"label,omitempty"`
	LimitToOptions *bool                              `json:"limitToOptions,omitempty"`
	Max            *float32                           `json:"max,omitempty"`
	Min            *float32                           `json:"min,omitempty"`
	Multiple       *bool                              `json:"multiple,omitempty"`
	MultipleLimit  *int32                             `json:"multipleLimit,omitempty"`
	Name           *string                            `json:"name,omitempty"`
	Options        *[]ParameterOptionDTO              `json:"options,omitempty"`
	Pattern        *string                            `json:"pattern,omitempty"`
	ReadOnly       *bool                              `json:"readOnly,omitempty"`
	Required       *bool                              `json:"required,omitempty"`
	Stepsize       *float32                           `json:"stepsize,omitempty"`
	Type           *ConfigDescriptionParameterDTOType `json:"type,omitempty"`
	Unit           *string                            `json:"unit,omitempty"`
	UnitLabel      *string                            `json:"unitLabel,omitempty"`
	Verify         *bool                              `json:"verify,omitempty"`
}

// ConfigDescriptionParameterDTOType defines model for ConfigDescriptionParameterDTO.Type.
// +kubebuilder:object:generate=true
type ConfigDescriptionParameterDTOType string

// ConfigDescriptionParameterGroupDTO defines model for ConfigDescriptionParameterGroupDTO.
// +kubebuilder:object:generate=true
type ConfigDescriptionParameterGroupDTO struct {
	Advanced    *bool   `json:"advanced,omitempty"`
	Context     *string `json:"context,omitempty"`
	Description *string `json:"description,omitempty"`
	Label       *string `json:"label,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ConfigStatusMessage defines model for ConfigStatusMessage.
// +kubebuilder:object:generate=true
type ConfigStatusMessage struct {
	Message       *string                  `json:"message,omitempty"`
	ParameterName *string                  `json:"parameterName,omitempty"`
	StatusCode    *int32                   `json:"statusCode,omitempty"`
	Type          *ConfigStatusMessageType `json:"type,omitempty"`
}

// ConfigStatusMessageType defines model for ConfigStatusMessage.Type.
// +kubebuilder:object:generate=true
type ConfigStatusMessageType string

// ConfigurableServiceDTO defines model for ConfigurableServiceDTO.
// +kubebuilder:object:generate=true
type ConfigurableServiceDTO struct {
	Category             *string `json:"category,omitempty"`
	ConfigDescriptionURI *string `json:"configDescriptionURI,omitempty"`
	Id                   *string `json:"id,omitempty"`
	Label                *string `json:"label,omitempty"`
	Multiple             *bool   `json:"multiple,omitempty"`
}

// Configuration defines model for Configuration.
// +kubebuilder:object:generate=true
type Configuration struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Properties json.RawMessage `json:"properties,omitempty"`
}

// DimensionInfo defines model for DimensionInfo.
// +kubebuilder:object:generate=true
type DimensionInfo struct {
	Dimension  *string `json:"dimension,omitempty"`
	SystemUnit *string `json:"systemUnit,omitempty"`
}

// DiscoveryResultDTO defines model for DiscoveryResultDTO.
// +kubebuilder:object:generate=true
type DiscoveryResultDTO struct {
	BridgeUID              *string                 `json:"bridgeUID,omitempty"`
	Flag                   *DiscoveryResultDTOFlag `json:"flag,omitempty"`
	Label                  *string                 `json:"label,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Properties             json.RawMessage         `json:"properties,omitempty"`
	RepresentationProperty *string                 `json:"representationProperty,omitempty"`
	ThingTypeUID           *string                 `json:"thingTypeUID,omitempty"`
	ThingUID               *string                 `json:"thingUID,omitempty"`
}

// DiscoveryResultDTOFlag defines model for DiscoveryResultDTO.Flag.
// +kubebuilder:object:generate=true
type DiscoveryResultDTOFlag string

// EnrichedChannelDTO defines model for EnrichedChannelDTO.
// +kubebuilder:object:generate=true
type EnrichedChannelDTO struct {
	AutoUpdatePolicy *string            `json:"autoUpdatePolicy,omitempty"`
	ChannelTypeUID   *string            `json:"channelTypeUID,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration    json.RawMessage    `json:"configuration,omitempty"`
	DefaultTags      *[]string          `json:"defaultTags,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Id               *string            `json:"id,omitempty"`
	ItemType         *string            `json:"itemType,omitempty"`
	Kind             *string            `json:"kind,omitempty"`
	Label            *string            `json:"label,omitempty"`
	LinkedItems      *[]string          `json:"linkedItems,omitempty"`
	Properties       *map[string]string `json:"properties,omitempty"`
	Uid              *string            `json:"uid,omitempty"`
}

// EnrichedItemChannelLinkDTO defines model for EnrichedItemChannelLinkDTO.
// +kubebuilder:object:generate=true
type EnrichedItemChannelLinkDTO struct {
	ChannelUID    *string         `json:"channelUID,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage `json:"configuration,omitempty"`
	Editable      *bool           `json:"editable,omitempty"`
	ItemName      *string         `json:"itemName,omitempty"`
}

// EnrichedItemDTO defines model for EnrichedItemDTO.
// +kubebuilder:object:generate=true
type EnrichedItemDTO struct {
	Category           *string             `json:"category,omitempty"`
	CommandDescription *CommandDescription `json:"commandDescription,omitempty"`
	Editable           *bool               `json:"editable,omitempty"`
	GroupNames         *[]string           `json:"groupNames,omitempty"`
	Label              *string             `json:"label,omitempty"`
	Link               *string             `json:"link,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Metadata           json.RawMessage     `json:"metadata,omitempty"`
	Name               *string             `json:"name,omitempty"`
	State              *string             `json:"state,omitempty"`
	StateDescription   *StateDescription   `json:"stateDescription,omitempty"`
	Tags               *[]string           `json:"tags,omitempty"`
	TransformedState   *string             `json:"transformedState,omitempty"`
	Type               *string             `json:"type,omitempty"`
	UnitSymbol         *string             `json:"unitSymbol,omitempty"`
}

// EnrichedRuleDTO defines model for EnrichedRuleDTO.
// +kubebuilder:object:generate=true
type EnrichedRuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration      json.RawMessage                  `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Editable           *bool                            `json:"editable,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Status             *RuleStatusInfo                  `json:"status,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *EnrichedRuleDTOVisibility       `json:"visibility,omitempty"`
}

// EnrichedRuleDTOVisibility defines model for EnrichedRuleDTO.Visibility.
// +kubebuilder:object:generate=true
type EnrichedRuleDTOVisibility string

// EnrichedSemanticTagDTO defines model for EnrichedSemanticTagDTO.
// +kubebuilder:object:generate=true
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type EnrichedSemanticTagDTO json.RawMessage

// EnrichedThingDTO defines model for EnrichedThingDTO.
// +kubebuilder:object:generate=true
type EnrichedThingDTO struct {
	UID            *string               `json:"UID,omitempty"`
	BridgeUID      *string               `json:"bridgeUID,omitempty"`
	Channels       *[]EnrichedChannelDTO `json:"channels,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration  json.RawMessage       `json:"configuration,omitempty"`
	Editable       *bool                 `json:"editable,omitempty"`
	FirmwareStatus *FirmwareStatusDTO    `json:"firmwareStatus,omitempty"`
	Label          *string               `json:"label,omitempty"`
	Location       *string               `json:"location,omitempty"`
	Properties     *map[string]string    `json:"properties,omitempty"`
	StatusInfo     *ThingStatusInfo      `json:"statusInfo,omitempty"`
	ThingTypeUID   *string               `json:"thingTypeUID,omitempty"`
}

// FilterCriteria defines model for FilterCriteria.
// +kubebuilder:object:generate=true
type FilterCriteria struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FilterCriteriaDTO defines model for FilterCriteriaDTO.
// +kubebuilder:object:generate=true
type FilterCriteriaDTO struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FirmwareDTO defines model for FirmwareDTO.
// +kubebuilder:object:generate=true
type FirmwareDTO struct {
	Changelog           *string `json:"changelog,omitempty"`
	Description         *string `json:"description,omitempty"`
	Model               *string `json:"model,omitempty"`
	ModelRestricted     *bool   `json:"modelRestricted,omitempty"`
	PrerequisiteVersion *string `json:"prerequisiteVersion,omitempty"`
	ThingTypeUID        *string `json:"thingTypeUID,omitempty"`
	Vendor              *string `json:"vendor,omitempty"`
	Version             *string `json:"version,omitempty"`
}

// FirmwareStatusDTO defines model for FirmwareStatusDTO.
// +kubebuilder:object:generate=true
type FirmwareStatusDTO struct {
	Status           *string `json:"status,omitempty"`
	UpdatableVersion *string `json:"updatableVersion,omitempty"`
}

// GalleryItem defines model for GalleryItem.
// +kubebuilder:object:generate=true
type GalleryItem struct {
	Author          *string      `json:"author,omitempty"`
	AuthorAvatarUrl *string      `json:"authorAvatarUrl,omitempty"`
	AuthorName      *string      `json:"authorName,omitempty"`
	CreatedDate     *OpenHABTime `json:"createdDate,omitempty"`
	Description     *string      `json:"description,omitempty"`
	Id              *string      `json:"id,omitempty"`
	ImageUrl        *string      `json:"imageUrl,omitempty"`
	Likes           *int32       `json:"likes,omitempty"`
	Posts           *int32       `json:"posts,omitempty"`
	Readme          *string      `json:"readme,omitempty"`
	Title           *string      `json:"title,omitempty"`
	UpdatedDate     *OpenHABTime `json:"updatedDate,omitempty"`
	Views           *int32       `json:"views,omitempty"`
}

// GalleryWidgetsListItem defines model for GalleryWidgetsListItem.
// +kubebuilder:object:generate=true
type GalleryWidgetsListItem struct {
	CreatedDate *OpenHABTime `json:"createdDate,omitempty"`
	Description *string      `json:"description,omitempty"`
	Id          *string      `json:"id,omitempty"`
	ImageUrl    *string      `json:"imageUrl,omitempty"`
	Likes       *int32       `json:"likes,omitempty"`
	Posts       *int32       `json:"posts,omitempty"`
	Title       *string      `json:"title,omitempty"`
	Views       *int32       `json:"views,omitempty"`
}

// GroupFunctionDTO defines model for GroupFunctionDTO.
// +kubebuilder:object:generate=true
type GroupFunctionDTO struct {
	Name   *string   `json:"name,omitempty"`
	Params *[]string `json:"params,omitempty"`
}

// GroupItemDTO defines model for GroupItemDTO.
// +kubebuilder:object:generate=true
type GroupItemDTO struct {
	Category   *string           `json:"category,omitempty"`
	Function   *GroupFunctionDTO `json:"function,omitempty"`
	GroupNames *[]string         `json:"groupNames,omitempty"`
	GroupType  *string           `json:"groupType,omitempty"`
	Label      *string           `json:"label,omitempty"`
	Name       *string           `json:"name,omitempty"`
	Tags       *[]string         `json:"tags,omitempty"`
	Type       *string           `json:"type,omitempty"`
}

// HistoryDataBean defines model for HistoryDataBean.
// +kubebuilder:object:generate=true
type HistoryDataBean struct {
	State *string `json:"state,omitempty"`
	Time  *int64  `json:"time,omitempty"`
}

// HumanLanguageInterpreterDTO defines model for HumanLanguageInterpreterDTO.
// +kubebuilder:object:generate=true
type HumanLanguageInterpreterDTO struct {
	Id      *string   `json:"id,omitempty"`
	Label   *string   `json:"label,omitempty"`
	Locales *[]string `json:"locales,omitempty"`
}

// IconSet defines model for IconSet.
// +kubebuilder:object:generate=true
type IconSet struct {
	Description *string           `json:"description,omitempty"`
	Formats     *[]IconSetFormats `json:"formats,omitempty"`
	Id          *string           `json:"id,omitempty"`
	Label       *string           `json:"label,omitempty"`
}

// IconSetFormats defines model for IconSet.Formats.
// +kubebuilder:object:generate=true
type IconSetFormats string

// Input defines model for Input.
// +kubebuilder:object:generate=true
type Input struct {
	DefaultValue *string   `json:"defaultValue,omitempty"`
	Description  *string   `json:"description,omitempty"`
	Label        *string   `json:"label,omitempty"`
	Name         *string   `json:"name,omitempty"`
	Reference    *string   `json:"reference,omitempty"`
	Required     *bool     `json:"required,omitempty"`
	Tags         *[]string `json:"tags,omitempty"`
	Type         *string   `json:"type,omitempty"`
}

// ItemChannelLinkDTO defines model for ItemChannelLinkDTO.
// +kubebuilder:object:generate=true
type ItemChannelLinkDTO struct {
	ChannelUID    *string         `json:"channelUID,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage `json:"configuration,omitempty"`
	ItemName      *string         `json:"itemName,omitempty"`
}

// ItemHistoryDTO defines model for ItemHistoryDTO.
// +kubebuilder:object:generate=true
type ItemHistoryDTO struct {
	Data         *[]HistoryDataBean `json:"data,omitempty"`
	Datapoints   *string            `json:"datapoints,omitempty"`
	Name         *string            `json:"name,omitempty"`
	Totalrecords *string            `json:"totalrecords,omitempty"`
}

// Links defines model for Links.
// +kubebuilder:object:generate=true
type Links struct {
	Type *string `json:"type,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// LoggerBean defines model for LoggerBean.
// +kubebuilder:object:generate=true
type LoggerBean struct {
	Loggers *[]LoggerInfo `json:"loggers,omitempty"`
}

// LoggerInfo defines model for LoggerInfo.
// +kubebuilder:object:generate=true
type LoggerInfo struct {
	Level      *string `json:"level,omitempty"`
	LoggerName *string `json:"loggerName,omitempty"`
}

// MappingDTO defines model for MappingDTO.
// +kubebuilder:object:generate=true
type MappingDTO struct {
	Column         *int32  `json:"column,omitempty"`
	Command        *string `json:"command,omitempty"`
	Icon           *string `json:"icon,omitempty"`
	Label          *string `json:"label,omitempty"`
	ReleaseCommand *string `json:"releaseCommand,omitempty"`
	Row            *int32  `json:"row,omitempty"`
}

// MetadataDTO defines model for MetadataDTO.
// +kubebuilder:object:generate=true
type MetadataDTO struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Config json.RawMessage `json:"config,omitempty"`
	Value  *string         `json:"value,omitempty"`
}

// Module defines model for Module.
// +kubebuilder:object:generate=true
type Module struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// ModuleDTO defines model for ModuleDTO.
// +kubebuilder:object:generate=true
type ModuleDTO struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage `json:"configuration,omitempty"`
	Description   *string         `json:"description,omitempty"`
	Id            *string         `json:"id,omitempty"`
	Label         *string         `json:"label,omitempty"`
	Type          *string         `json:"type,omitempty"`
}

// ModuleTypeDTO defines model for ModuleTypeDTO.
// +kubebuilder:object:generate=true
type ModuleTypeDTO struct {
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Label              *string                          `json:"label,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *ModuleTypeDTOVisibility         `json:"visibility,omitempty"`
}

// ModuleTypeDTOVisibility defines model for ModuleTypeDTO.Visibility.
// +kubebuilder:object:generate=true
type ModuleTypeDTOVisibility string

// Output defines model for Output.
// +kubebuilder:object:generate=true
type Output struct {
	DefaultValue *string   `json:"defaultValue,omitempty"`
	Description  *string   `json:"description,omitempty"`
	Label        *string   `json:"label,omitempty"`
	Name         *string   `json:"name,omitempty"`
	Reference    *string   `json:"reference,omitempty"`
	Tags         *[]string `json:"tags,omitempty"`
	Type         *string   `json:"type,omitempty"`
}

// PageDTO defines model for PageDTO.
// +kubebuilder:object:generate=true
type PageDTO struct {
	Icon    *string      `json:"icon,omitempty"`
	Id      *string      `json:"id,omitempty"`
	Leaf    *bool        `json:"leaf,omitempty"`
	Link    *string      `json:"link,omitempty"`
	Parent  *PageDTO     `json:"parent,omitempty"`
	Timeout *bool        `json:"timeout,omitempty"`
	Title   *string      `json:"title,omitempty"`
	Widgets *[]WidgetDTO `json:"widgets,omitempty"`
}

// ParameterOption defines model for ParameterOption.
// +kubebuilder:object:generate=true
type ParameterOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// ParameterOptionDTO defines model for ParameterOptionDTO.
// +kubebuilder:object:generate=true
type ParameterOptionDTO struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// PersistenceCronStrategyDTO defines model for PersistenceCronStrategyDTO.
// +kubebuilder:object:generate=true
type PersistenceCronStrategyDTO struct {
	CronExpression *string `json:"cronExpression,omitempty"`
	Name           *string `json:"name,omitempty"`
}

// PersistenceFilterDTO defines model for PersistenceFilterDTO.
// +kubebuilder:object:generate=true
type PersistenceFilterDTO struct {
	Inverted *bool     `json:"inverted,omitempty"`
	Lower    *float32  `json:"lower,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Relative *bool     `json:"relative,omitempty"`
	Unit     *string   `json:"unit,omitempty"`
	Upper    *float32  `json:"upper,omitempty"`
	Value    *float32  `json:"value,omitempty"`
	Values   *[]string `json:"values,omitempty"`
}

// PersistenceItemConfigurationDTO defines model for PersistenceItemConfigurationDTO.
// +kubebuilder:object:generate=true
type PersistenceItemConfigurationDTO struct {
	Alias      *string   `json:"alias,omitempty"`
	Filters    *[]string `json:"filters,omitempty"`
	Items      *[]string `json:"items,omitempty"`
	Strategies *[]string `json:"strategies,omitempty"`
}

// PersistenceItemInfo defines model for PersistenceItemInfo.
// +kubebuilder:object:generate=true
type PersistenceItemInfo struct {
	Count    *int32       `json:"count,omitempty"`
	Earliest *OpenHABTime `json:"earliest,omitempty"`
	Latest   *OpenHABTime `json:"latest,omitempty"`
	Name     *string      `json:"name,omitempty"`
}

// PersistenceServiceConfigurationDTO defines model for PersistenceServiceConfigurationDTO.
// +kubebuilder:object:generate=true
type PersistenceServiceConfigurationDTO struct {
	Configs          *[]PersistenceItemConfigurationDTO `json:"configs,omitempty"`
	CronStrategies   *[]PersistenceCronStrategyDTO      `json:"cronStrategies,omitempty"`
	Defaults         *[]string                          `json:"defaults,omitempty"`
	Editable         *bool                              `json:"editable,omitempty"`
	EqualsFilters    *[]PersistenceFilterDTO            `json:"equalsFilters,omitempty"`
	IncludeFilters   *[]PersistenceFilterDTO            `json:"includeFilters,omitempty"`
	ServiceId        *string                            `json:"serviceId,omitempty"`
	ThresholdFilters *[]PersistenceFilterDTO            `json:"thresholdFilters,omitempty"`
	TimeFilters      *[]PersistenceFilterDTO            `json:"timeFilters,omitempty"`
}

// PersistenceServiceDTO defines model for PersistenceServiceDTO.
// +kubebuilder:object:generate=true
type PersistenceServiceDTO struct {
	Id    *string `json:"id,omitempty"`
	Label *string `json:"label,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// ProfileTypeDTO defines model for ProfileTypeDTO.
// +kubebuilder:object:generate=true
type ProfileTypeDTO struct {
	Kind               *string   `json:"kind,omitempty"`
	Label              *string   `json:"label,omitempty"`
	SupportedItemTypes *[]string `json:"supportedItemTypes,omitempty"`
	Uid                *string   `json:"uid,omitempty"`
}

// RootBean defines model for RootBean.
// +kubebuilder:object:generate=true
type RootBean struct {
	Links             *[]Links     `json:"links,omitempty"`
	Locale            *string      `json:"locale,omitempty"`
	MeasurementSystem *string      `json:"measurementSystem,omitempty"`
	RuntimeInfo       *RuntimeInfo `json:"runtimeInfo,omitempty"`
	Version           *string      `json:"version,omitempty"`
}

// RootUIComponent defines model for RootUIComponent.
// +kubebuilder:object:generate=true
type RootUIComponent struct {
	Component *string                   `json:"component,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Config    json.RawMessage           `json:"config,omitempty"`
	Props     *ConfigDescriptionDTO     `json:"props,omitempty"`
	Slots     *map[string][]UIComponent `json:"slots,omitempty"`
	Tags      *[]string                 `json:"tags,omitempty"`
	Timestamp *OpenHABTime              `json:"timestamp,omitempty"`
	Type      *string                   `json:"type,omitempty"`
	Uid       *string                   `json:"uid,omitempty"`
}

// Rule defines model for Rule.
// +kubebuilder:object:generate=true
type Rule struct {
	Actions                   *[]Action                     `json:"actions,omitempty"`
	Conditions                *[]Condition                  `json:"conditions,omitempty"`
	Configuration             *Configuration                `json:"configuration,omitempty"`
	ConfigurationDescriptions *[]ConfigDescriptionParameter `json:"configurationDescriptions,omitempty"`
	Description               *string                       `json:"description,omitempty"`
	Modules                   *[]Module                     `json:"modules,omitempty"`
	Name                      *string                       `json:"name,omitempty"`
	Tags                      *[]string                     `json:"tags,omitempty"`
	TemplateUID               *string                       `json:"templateUID,omitempty"`
	Triggers                  *[]Trigger                    `json:"triggers,omitempty"`
	Uid                       *string                       `json:"uid,omitempty"`
	Visibility                *RuleVisibility               `json:"visibility,omitempty"`
}

// RuleVisibility defines model for Rule.Visibility.
// +kubebuilder:object:generate=true
type RuleVisibility string

// RuleDTO defines model for RuleDTO.
// +kubebuilder:object:generate=true
type RuleDTO struct {
	Actions            *[]ActionDTO                     `json:"actions,omitempty"`
	Conditions         *[]ConditionDTO                  `json:"conditions,omitempty"`
	ConfigDescriptions *[]ConfigDescriptionParameterDTO `json:"configDescriptions,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration      json.RawMessage                  `json:"configuration,omitempty"`
	Description        *string                          `json:"description,omitempty"`
	Name               *string                          `json:"name,omitempty"`
	Tags               *[]string                        `json:"tags,omitempty"`
	TemplateUID        *string                          `json:"templateUID,omitempty"`
	Triggers           *[]TriggerDTO                    `json:"triggers,omitempty"`
	Uid                *string                          `json:"uid,omitempty"`
	Visibility         *RuleDTOVisibility               `json:"visibility,omitempty"`
}

// RuleDTOVisibility defines model for RuleDTO.Visibility.
// +kubebuilder:object:generate=true
type RuleDTOVisibility string

// RuleExecution defines model for RuleExecution.
// +kubebuilder:object:generate=true
type RuleExecution struct {
	Date *OpenHABTime `json:"date,omitempty"`
	Rule *Rule        `json:"rule,omitempty"`
}

// RuleStatusInfo defines model for RuleStatusInfo.
// +kubebuilder:object:generate=true
type RuleStatusInfo struct {
	Description  *string                     `json:"description,omitempty"`
	Status       *RuleStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *RuleStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// RuleStatusInfoStatus defines model for RuleStatusInfo.Status.
// +kubebuilder:object:generate=true
type RuleStatusInfoStatus string

// RuleStatusInfoStatusDetail defines model for RuleStatusInfo.StatusDetail.
// +kubebuilder:object:generate=true
type RuleStatusInfoStatusDetail string

// RuntimeInfo defines model for RuntimeInfo.
// +kubebuilder:object:generate=true
type RuntimeInfo struct {
	BuildString *string `json:"buildString,omitempty"`
	Version     *string `json:"version,omitempty"`
}

// SitemapDTO defines model for SitemapDTO.
// +kubebuilder:object:generate=true
type SitemapDTO struct {
	Homepage *PageDTO `json:"homepage,omitempty"`
	Icon     *string  `json:"icon,omitempty"`
	Label    *string  `json:"label,omitempty"`
	Link     *string  `json:"link,omitempty"`
	Name     *string  `json:"name,omitempty"`
}

// StateDescription defines model for StateDescription.
// +kubebuilder:object:generate=true
type StateDescription struct {
	Maximum  *float32       `json:"maximum,omitempty"`
	Minimum  *float32       `json:"minimum,omitempty"`
	Options  *[]StateOption `json:"options,omitempty"`
	Pattern  *string        `json:"pattern,omitempty"`
	ReadOnly *bool          `json:"readOnly,omitempty"`
	Step     *float32       `json:"step,omitempty"`
}

// StateOption defines model for StateOption.
// +kubebuilder:object:generate=true
type StateOption struct {
	Label *string `json:"label,omitempty"`
	Value *string `json:"value,omitempty"`
}

// StrippedThingTypeDTO defines model for StrippedThingTypeDTO.
// +kubebuilder:object:generate=true
type StrippedThingTypeDTO struct {
	UID                     *string   `json:"UID,omitempty"`
	Bridge                  *bool     `json:"bridge,omitempty"`
	Category                *string   `json:"category,omitempty"`
	Description             *string   `json:"description,omitempty"`
	Label                   *string   `json:"label,omitempty"`
	Listed                  *bool     `json:"listed,omitempty"`
	SupportedBridgeTypeUIDs *[]string `json:"supportedBridgeTypeUIDs,omitempty"`
}

// SystemInfo defines model for SystemInfo.
// +kubebuilder:object:generate=true
type SystemInfo struct {
	AvailableProcessors *int32  `json:"availableProcessors,omitempty"`
	ConfigFolder        *string `json:"configFolder,omitempty"`
	FreeMemory          *int64  `json:"freeMemory,omitempty"`
	JavaVendor          *string `json:"javaVendor,omitempty"`
	JavaVendorVersion   *string `json:"javaVendorVersion,omitempty"`
	JavaVersion         *string `json:"javaVersion,omitempty"`
	LogFolder           *string `json:"logFolder,omitempty"`
	OsArchitecture      *string `json:"osArchitecture,omitempty"`
	OsName              *string `json:"osName,omitempty"`
	OsVersion           *string `json:"osVersion,omitempty"`
	StartLevel          *int32  `json:"startLevel,omitempty"`
	TotalMemory         *int64  `json:"totalMemory,omitempty"`
	Uptime              *int64  `json:"uptime,omitempty"`
	UserdataFolder      *string `json:"userdataFolder,omitempty"`
}

// SystemInfoBean defines model for SystemInfoBean.
// +kubebuilder:object:generate=true
type SystemInfoBean struct {
	SystemInfo *SystemInfo `json:"systemInfo,omitempty"`
}

// Template defines model for Template.
// +kubebuilder:object:generate=true
type Template struct {
	Description *string             `json:"description,omitempty"`
	Label       *string             `json:"label,omitempty"`
	Tags        *[]string           `json:"tags,omitempty"`
	Uid         *string             `json:"uid,omitempty"`
	Visibility  *TemplateVisibility `json:"visibility,omitempty"`
}

// TemplateVisibility defines model for Template.Visibility.
// +kubebuilder:object:generate=true
type TemplateVisibility string

// ThingActionDTO defines model for ThingActionDTO.
// +kubebuilder:object:generate=true
type ThingActionDTO struct {
	ActionUid   *string   `json:"actionUid,omitempty"`
	Description *string   `json:"description,omitempty"`
	Inputs      *[]Input  `json:"inputs,omitempty"`
	Label       *string   `json:"label,omitempty"`
	Outputs     *[]Output `json:"outputs,omitempty"`
}

// ThingDTO defines model for ThingDTO.
// +kubebuilder:object:generate=true
type ThingDTO struct {
	UID           *string            `json:"UID,omitempty"`
	BridgeUID     *string            `json:"bridgeUID,omitempty"`
	Channels      *[]ChannelDTO      `json:"channels,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage    `json:"configuration,omitempty"`
	Label         *string            `json:"label,omitempty"`
	Location      *string            `json:"location,omitempty"`
	Properties    *map[string]string `json:"properties,omitempty"`
	ThingTypeUID  *string            `json:"thingTypeUID,omitempty"`
}

// ThingStatusInfo defines model for ThingStatusInfo.
// +kubebuilder:object:generate=true
type ThingStatusInfo struct {
	Description  *string                      `json:"description,omitempty"`
	Status       *ThingStatusInfoStatus       `json:"status,omitempty"`
	StatusDetail *ThingStatusInfoStatusDetail `json:"statusDetail,omitempty"`
}

// ThingStatusInfoStatus defines model for ThingStatusInfo.Status.
// +kubebuilder:object:generate=true
type ThingStatusInfoStatus string

// ThingStatusInfoStatusDetail defines model for ThingStatusInfo.StatusDetail.
// +kubebuilder:object:generate=true
type ThingStatusInfoStatusDetail string

// ThingTypeDTO defines model for ThingTypeDTO.
// +kubebuilder:object:generate=true
type ThingTypeDTO struct {
	UID                      *string                               `json:"UID,omitempty"`
	Bridge                   *bool                                 `json:"bridge,omitempty"`
	Category                 *string                               `json:"category,omitempty"`
	ChannelGroups            *[]ChannelGroupDefinitionDTO          `json:"channelGroups,omitempty"`
	Channels                 *[]ChannelDefinitionDTO               `json:"channels,omitempty"`
	ConfigParameters         *[]ConfigDescriptionParameterDTO      `json:"configParameters,omitempty"`
	Description              *string                               `json:"description,omitempty"`
	ExtensibleChannelTypeIds *[]string                             `json:"extensibleChannelTypeIds,omitempty"`
	Label                    *string                               `json:"label,omitempty"`
	Listed                   *bool                                 `json:"listed,omitempty"`
	ParameterGroups          *[]ConfigDescriptionParameterGroupDTO `json:"parameterGroups,omitempty"`
	Properties               *map[string]string                    `json:"properties,omitempty"`
	SupportedBridgeTypeUIDs  *[]string                             `json:"supportedBridgeTypeUIDs,omitempty"`
}

// TileDTO defines model for TileDTO.
// +kubebuilder:object:generate=true
type TileDTO struct {
	ImageUrl *string `json:"imageUrl,omitempty"`
	Name     *string `json:"name,omitempty"`
	Overlay  *string `json:"overlay,omitempty"`
	Url      *string `json:"url,omitempty"`
}

// TokenResponseDTO defines model for TokenResponseDTO.
// +kubebuilder:object:generate=true
type TokenResponseDTO struct {
	AccessToken  *string  `json:"access_token,omitempty"`
	ExpiresIn    *int32   `json:"expires_in,omitempty"`
	RefreshToken *string  `json:"refresh_token,omitempty"`
	Scope        *string  `json:"scope,omitempty"`
	TokenType    *string  `json:"token_type,omitempty"`
	User         *UserDTO `json:"user,omitempty"`
}

// Transformation defines model for Transformation.
// +kubebuilder:object:generate=true
type Transformation struct {
	Configuration *map[string]string `json:"configuration,omitempty"`
	Label         *string            `json:"label,omitempty"`
	Type          *string            `json:"type,omitempty"`
	Uid           *string            `json:"uid,omitempty"`
}

// TransformationDTO defines model for TransformationDTO.
// +kubebuilder:object:generate=true
type TransformationDTO struct {
	Configuration *map[string]string `json:"configuration,omitempty"`
	Editable      *bool              `json:"editable,omitempty"`
	Label         *string            `json:"label,omitempty"`
	Type          *string            `json:"type,omitempty"`
	Uid           *string            `json:"uid,omitempty"`
}

// Trigger defines model for Trigger.
// +kubebuilder:object:generate=true
type Trigger struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	Description   *string        `json:"description,omitempty"`
	Id            *string        `json:"id,omitempty"`
	Label         *string        `json:"label,omitempty"`
	TypeUID       *string        `json:"typeUID,omitempty"`
}

// TriggerDTO defines model for TriggerDTO.
// +kubebuilder:object:generate=true
type TriggerDTO struct {
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Configuration json.RawMessage `json:"configuration,omitempty"`
	Description   *string         `json:"description,omitempty"`
	Id            *string         `json:"id,omitempty"`
	Label         *string         `json:"label,omitempty"`
	Type          *string         `json:"type,omitempty"`
}

// UIComponent defines model for UIComponent.
// +kubebuilder:object:generate=true
type UIComponent struct {
	Component *string                       `json:"component,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Config    json.RawMessage               `json:"config,omitempty"`
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	Slots     *map[string][]json.RawMessage `json:"slots,omitempty"`
	Type      *string                       `json:"type,omitempty"`
}

// UoMInfo defines model for UoMInfo.
// +kubebuilder:object:generate=true
type UoMInfo struct {
	Dimensions *[]DimensionInfo `json:"dimensions,omitempty"`
}

// UoMInfoBean defines model for UoMInfoBean.
// +kubebuilder:object:generate=true
type UoMInfoBean struct {
	UomInfo *UoMInfo `json:"uomInfo,omitempty"`
}

// UserApiTokenDTO defines model for UserApiTokenDTO.
// +kubebuilder:object:generate=true
type UserApiTokenDTO struct {
	CreatedTime *OpenHABTime `json:"createdTime,omitempty"`
	Name        *string      `json:"name,omitempty"`
	Scope       *string      `json:"scope,omitempty"`
}

// UserDTO defines model for UserDTO.
// +kubebuilder:object:generate=true
type UserDTO struct {
	Name  *string   `json:"name,omitempty"`
	Roles *[]string `json:"roles,omitempty"`
}

// UserSessionDTO defines model for UserSessionDTO.
// +kubebuilder:object:generate=true
type UserSessionDTO struct {
	ClientId        *string      `json:"clientId,omitempty"`
	CreatedTime     *OpenHABTime `json:"createdTime,omitempty"`
	LastRefreshTime *OpenHABTime `json:"lastRefreshTime,omitempty"`
	Scope           *string      `json:"scope,omitempty"`
	SessionId       *string      `json:"sessionId,omitempty"`
}

// VoiceDTO defines model for VoiceDTO.
// +kubebuilder:object:generate=true
type VoiceDTO struct {
	Id     *string `json:"id,omitempty"`
	Label  *string `json:"label,omitempty"`
	Locale *string `json:"locale,omitempty"`
}

// WidgetDTO defines model for WidgetDTO.
// +kubebuilder:object:generate=true
type WidgetDTO struct {
	Column              *int32           `json:"column,omitempty"`
	Command             *string          `json:"command,omitempty"`
	Encoding            *string          `json:"encoding,omitempty"`
	ForceAsItem         *bool            `json:"forceAsItem,omitempty"`
	Height              *int32           `json:"height,omitempty"`
	Icon                *string          `json:"icon,omitempty"`
	Iconcolor           *string          `json:"iconcolor,omitempty"`
	InputHint           *string          `json:"inputHint,omitempty"`
	Item                *EnrichedItemDTO `json:"item,omitempty"`
	Label               *string          `json:"label,omitempty"`
	LabelSource         *string          `json:"labelSource,omitempty"`
	Labelcolor          *string          `json:"labelcolor,omitempty"`
	Legend              *bool            `json:"legend,omitempty"`
	LinkedPage          *PageDTO         `json:"linkedPage,omitempty"`
	Mappings            *[]MappingDTO    `json:"mappings,omitempty"`
	MaxValue            *float32         `json:"maxValue,omitempty"`
	MinValue            *float32         `json:"minValue,omitempty"`
	Name                *string          `json:"name,omitempty"`
	Pattern             *string          `json:"pattern,omitempty"`
	Period              *string          `json:"period,omitempty"`
	Refresh             *int32           `json:"refresh,omitempty"`
	ReleaseCommand      *string          `json:"releaseCommand,omitempty"`
	ReleaseOnly         *bool            `json:"releaseOnly,omitempty"`
	Row                 *int32           `json:"row,omitempty"`
	SendFrequency       *int32           `json:"sendFrequency,omitempty"`
	Service             *string          `json:"service,omitempty"`
	State               *string          `json:"state,omitempty"`
	Stateless           *bool            `json:"stateless,omitempty"`
	StaticIcon          *bool            `json:"staticIcon,omitempty"`
	Step                *float32         `json:"step,omitempty"`
	SwitchSupport       *bool            `json:"switchSupport,omitempty"`
	Type                *string          `json:"type,omitempty"`
	Unit                *string          `json:"unit,omitempty"`
	Url                 *string          `json:"url,omitempty"`
	Valuecolor          *string          `json:"valuecolor,omitempty"`
	Visibility          *bool            `json:"visibility,omitempty"`
	WidgetId            *string          `json:"widgetId,omitempty"`
	YAxisDecimalPattern *string          `json:"yAxisDecimalPattern,omitempty"`
}

// GetAvailableActionsForThingParams defines parameters for GetAvailableActionsForThing.
type GetAvailableActionsForThingParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// ExecuteThingActionJSONBody defines parameters for ExecuteThingAction.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type ExecuteThingActionJSONBody = json.RawMessage

// ExecuteThingActionParams defines parameters for ExecuteThingAction.
type ExecuteThingActionParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonsParams defines parameters for GetAddons.
type GetAddonsParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonTypesParams defines parameters for GetAddonTypes.
type GetAddonTypesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetSuggestedAddonsParams defines parameters for GetSuggestedAddons.
type GetSuggestedAddonsParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonServicesParams defines parameters for GetAddonServices.
type GetAddonServicesParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonByIdParams defines parameters for GetAddonById.
type GetAddonByIdParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAddonConfigurationParams defines parameters for GetAddonConfiguration.
type GetAddonConfigurationParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`
}

// UpdateAddonConfigurationJSONBody defines parameters for UpdateAddonConfiguration.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type UpdateAddonConfigurationJSONBody = json.RawMessage

// UpdateAddonConfigurationParams defines parameters for UpdateAddonConfiguration.
type UpdateAddonConfigurationParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`
}

// InstallAddonByIdParams defines parameters for InstallAddonById.
type InstallAddonByIdParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`
}

// UninstallAddonParams defines parameters for UninstallAddon.
type UninstallAddonParams struct {
	// ServiceId service ID
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`
}

// GetAudioDefaultSinkParams defines parameters for GetAudioDefaultSink.
type GetAudioDefaultSinkParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioDefaultSourceParams defines parameters for GetAudioDefaultSource.
type GetAudioDefaultSourceParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSinksParams defines parameters for GetAudioSinks.
type GetAudioSinksParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAudioSourcesParams defines parameters for GetAudioSources.
type GetAudioSourcesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// DeleteSessionFormdataBody defines parameters for DeleteSession.
type DeleteSessionFormdataBody struct {
	Id           *string `form:"id,omitempty" json:"id,omitempty"`
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`
}

// GetOAuthTokenFormdataBody defines parameters for GetOAuthToken.
type GetOAuthTokenFormdataBody struct {
	ClientId     *string `form:"client_id,omitempty" json:"client_id,omitempty"`
	Code         *string `form:"code,omitempty" json:"code,omitempty"`
	CodeVerifier *string `form:"code_verifier,omitempty" json:"code_verifier,omitempty"`
	GrantType    *string `form:"grant_type,omitempty" json:"grant_type,omitempty"`
	RedirectUri  *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`
}

// GetOAuthTokenParams defines parameters for GetOAuthToken.
type GetOAuthTokenParams struct {
	UseCookie *bool `form:"useCookie,omitempty" json:"useCookie,omitempty"`
}

// GetChannelTypesParams defines parameters for GetChannelTypes.
type GetChannelTypesParams struct {
	// Prefixes filter UIDs by prefix (multiple comma-separated prefixes allowed, for example: 'system,mqtt')
	Prefixes *string `form:"prefixes,omitempty" json:"prefixes,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetChannelTypeByUIDParams defines parameters for GetChannelTypeByUID.
type GetChannelTypeByUIDParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionsParams defines parameters for GetConfigDescriptions.
type GetConfigDescriptionsParams struct {
	// Scheme scheme filter
	Scheme *string `form:"scheme,omitempty" json:"scheme,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetConfigDescriptionByURIParams defines parameters for GetConfigDescriptionByURI.
type GetConfigDescriptionByURIParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// Topics topics
	Topics *string `form:"topics,omitempty" json:"topics,omitempty"`
}

// GetIconSetsParams defines parameters for GetIconSets.
type GetIconSetsParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetDiscoveredInboxItemsParams defines parameters for GetDiscoveredInboxItems.
type GetDiscoveredInboxItemsParams struct {
	// IncludeIgnored If true, include ignored inbox entries. Defaults to true
	IncludeIgnored *bool `form:"includeIgnored,omitempty" json:"includeIgnored,omitempty"`
}

// ApproveInboxItemByIdTextBody defines parameters for ApproveInboxItemById.
type ApproveInboxItemByIdTextBody = string

// ApproveInboxItemByIdParams defines parameters for ApproveInboxItemById.
type ApproveInboxItemByIdParams struct {
	// NewThingId new thing ID
	NewThingId *string `form:"newThingId,omitempty" json:"newThingId,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsParams defines parameters for GetItems.
type GetItemsParams struct {
	// Type item type filter
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Tags item tag filter
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`

	// Metadata metadata selector - a comma separated list or a regular expression (returns all if no value given)
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// Recursive get member items recursively
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// Fields limit output to the given fields (comma separated)
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// StaticDataOnly provides a cacheable list of values not expected to change regularly and checks the If-Modified-Since header, all other parameters are ignored except "metadata"
	StaticDataOnly *bool `form:"staticDataOnly,omitempty" json:"staticDataOnly,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// AddOrUpdateItemsInRegistryJSONBody defines parameters for AddOrUpdateItemsInRegistry.
type AddOrUpdateItemsInRegistryJSONBody = []GroupItemDTO

// GetSemanticItemParams defines parameters for GetSemanticItem.
type GetSemanticItemParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemByNameParams defines parameters for GetItemByName.
type GetItemByNameParams struct {
	// Metadata metadata selector - a comma separated list or a regular expression (returns all if no value given)
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// Recursive get member items if the item is a group item
	Recursive *bool `form:"recursive,omitempty" json:"recursive,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// SendItemCommandTextBody defines parameters for SendItemCommand.
type SendItemCommandTextBody = string

// AddOrUpdateItemInRegistryParams defines parameters for AddOrUpdateItemInRegistry.
type AddOrUpdateItemInRegistryParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemNamespacesParams defines parameters for GetItemNamespaces.
type GetItemNamespacesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateItemStateTextBody defines parameters for UpdateItemState.
type UpdateItemStateTextBody = string

// UpdateItemStateParams defines parameters for UpdateItemState.
type UpdateItemStateParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemLinksParams defines parameters for GetItemLinks.
type GetItemLinksParams struct {
	// ChannelUID filter by channel UID
	ChannelUID *string `form:"channelUID,omitempty" json:"channelUID,omitempty"`

	// ItemName filter by item name
	ItemName *string `form:"itemName,omitempty" json:"itemName,omitempty"`
}

// GetModuleTypesParams defines parameters for GetModuleTypes.
type GetModuleTypesParams struct {
	// Tags tags for filtering
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`

	// Type filtering by action, condition or trigger
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetModuleTypeByIdParams defines parameters for GetModuleTypeById.
type GetModuleTypeByIdParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetPersistenceServicesParams defines parameters for GetPersistenceServices.
type GetPersistenceServicesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetItemsForPersistenceServiceParams defines parameters for GetItemsForPersistenceService.
type GetItemsForPersistenceServiceParams struct {
	// ServiceId Id of the persistence service. If not provided the default service will be used
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`
}

// DeleteItemFromPersistenceServiceParams defines parameters for DeleteItemFromPersistenceService.
type DeleteItemFromPersistenceServiceParams struct {
	// ServiceId Id of the persistence service.
	ServiceId string `form:"serviceId" json:"serviceId"`

	// Starttime Start of the time range to be deleted. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime string `form:"starttime" json:"starttime"`

	// Endtime End of the time range to be deleted. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime string `form:"endtime" json:"endtime"`
}

// GetItemDataFromPersistenceServiceParams defines parameters for GetItemDataFromPersistenceService.
type GetItemDataFromPersistenceServiceParams struct {
	// ServiceId Id of the persistence service. If not provided the default service will be used
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`

	// Starttime Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Starttime *string `form:"starttime,omitempty" json:"starttime,omitempty"`

	// Endtime End time of the data to return. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Endtime *string `form:"endtime,omitempty" json:"endtime,omitempty"`

	// Page Page number of data to return. This parameter will enable paging.
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// Pagelength The length of each page.
	Pagelength *int32 `form:"pagelength,omitempty" json:"pagelength,omitempty"`

	// Boundary Gets one value before and after the requested period.
	Boundary *bool `form:"boundary,omitempty" json:"boundary,omitempty"`
}

// StoreItemDataInPersistenceServiceParams defines parameters for StoreItemDataInPersistenceService.
type StoreItemDataInPersistenceServiceParams struct {
	// ServiceId Id of the persistence service. If not provided the default service will be used
	ServiceId *string `form:"serviceId,omitempty" json:"serviceId,omitempty"`

	// Time Time of the data to be stored. Will default to current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Time string `form:"time" json:"time"`

	// State The state to store.
	State string `form:"state" json:"state"`
}

// GetProfileTypesParams defines parameters for GetProfileTypes.
type GetProfileTypesParams struct {
	// ChannelTypeUID channel type filter
	ChannelTypeUID *string `form:"channelTypeUID,omitempty" json:"channelTypeUID,omitempty"`

	// ItemType item type filter
	ItemType *string `form:"itemType,omitempty" json:"itemType,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	Prefix *string   `form:"prefix,omitempty" json:"prefix,omitempty"`
	Tags   *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Summary summary fields only
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`

	// StaticDataOnly provides a cacheable list of values not expected to change regularly and honors the If-Modified-Since header, all other parameters are ignored
	StaticDataOnly *bool `form:"staticDataOnly,omitempty" json:"staticDataOnly,omitempty"`
}

// GetScheduleRuleSimulationsParams defines parameters for GetScheduleRuleSimulations.
type GetScheduleRuleSimulationsParams struct {
	// From Start time of the simulated rule executions. Will default to the current time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// Until End time of the simulated rule executions. Will default to 30 days after the start time. Must be less than 180 days after the given start time. [yyyy-MM-dd'T'HH:mm:ss.SSSZ]
	Until *string `form:"until,omitempty" json:"until,omitempty"`
}

// UpdateRuleConfigurationJSONBody defines parameters for UpdateRuleConfiguration.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type UpdateRuleConfigurationJSONBody = json.RawMessage

// EnableRuleTextBody defines parameters for EnableRule.
type EnableRuleTextBody = string

// RunRuleNow1JSONBody defines parameters for RunRuleNow1.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type RunRuleNow1JSONBody = json.RawMessage

// SetRuleModuleConfigParameterTextBody defines parameters for SetRuleModuleConfigParameter.
type SetRuleModuleConfigParameterTextBody = string

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetServicesByIdParams defines parameters for GetServicesById.
type GetServicesByIdParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateServiceConfigJSONBody defines parameters for UpdateServiceConfig.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type UpdateServiceConfigJSONBody = json.RawMessage

// UpdateServiceConfigParams defines parameters for UpdateServiceConfig.
type UpdateServiceConfigParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetServiceContextParams defines parameters for GetServiceContext.
type GetServiceContextParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetSitemapEvents1Params defines parameters for GetSitemapEvents1.
type GetSitemapEvents1Params struct {
	// Sitemap sitemap name
	Sitemap *string `form:"sitemap,omitempty" json:"sitemap,omitempty"`

	// Pageid page id
	Pageid *string `form:"pageid,omitempty" json:"pageid,omitempty"`
}

// GetSitemapEventsParams defines parameters for GetSitemapEvents.
type GetSitemapEventsParams struct {
	// Sitemap sitemap name
	Sitemap *string `form:"sitemap,omitempty" json:"sitemap,omitempty"`
}

// GetSitemapByNameParams defines parameters for GetSitemapByName.
type GetSitemapByNameParams struct {
	Type         *string `form:"type,omitempty" json:"type,omitempty"`
	Jsoncallback *string `form:"jsoncallback,omitempty" json:"jsoncallback,omitempty"`

	// IncludeHidden include hidden widgets
	IncludeHidden *bool `form:"includeHidden,omitempty" json:"includeHidden,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// PollDataForSitemapParams defines parameters for PollDataForSitemap.
type PollDataForSitemapParams struct {
	// Subscriptionid subscriptionid
	Subscriptionid *string `form:"subscriptionid,omitempty" json:"subscriptionid,omitempty"`

	// IncludeHidden include hidden widgets
	IncludeHidden *bool `form:"includeHidden,omitempty" json:"includeHidden,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// PollDataForPageParams defines parameters for PollDataForPage.
type PollDataForPageParams struct {
	// Subscriptionid subscriptionid
	Subscriptionid *string `form:"subscriptionid,omitempty" json:"subscriptionid,omitempty"`

	// IncludeHidden include hidden widgets
	IncludeHidden *bool `form:"includeHidden,omitempty" json:"includeHidden,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetSemanticTagsParams defines parameters for GetSemanticTags.
type GetSemanticTagsParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CreateSemanticTagParams defines parameters for CreateSemanticTag.
type CreateSemanticTagParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// RemoveSemanticTagParams defines parameters for RemoveSemanticTag.
type RemoveSemanticTagParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetSemanticTagAndSubTagsParams defines parameters for GetSemanticTagAndSubTags.
type GetSemanticTagAndSubTagsParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateSemanticTagParams defines parameters for UpdateSemanticTag.
type UpdateSemanticTagParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplatesParams defines parameters for GetTemplates.
type GetTemplatesParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetTemplateByIdParams defines parameters for GetTemplateById.
type GetTemplateByIdParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypesParams defines parameters for GetThingTypes.
type GetThingTypesParams struct {
	// BindingId filter by binding Id
	BindingId *string `form:"bindingId,omitempty" json:"bindingId,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingTypeByIdParams defines parameters for GetThingTypeById.
type GetThingTypeByIdParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingsParams defines parameters for GetThings.
type GetThingsParams struct {
	// Summary summary fields only
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`

	// StaticDataOnly provides a cacheable list of values not expected to change regularly and checks the If-Modified-Since header
	StaticDataOnly *bool `form:"staticDataOnly,omitempty" json:"staticDataOnly,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// CreateThingInRegistryParams defines parameters for CreateThingInRegistry.
type CreateThingInRegistryParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// RemoveThingByIdParams defines parameters for RemoveThingById.
type RemoveThingByIdParams struct {
	// Force force
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingByIdParams defines parameters for GetThingById.
type GetThingByIdParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingParams defines parameters for UpdateThing.
type UpdateThingParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingConfigJSONBody defines parameters for UpdateThingConfig.
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
type UpdateThingConfigJSONBody = json.RawMessage

// UpdateThingConfigParams defines parameters for UpdateThingConfig.
type UpdateThingConfigParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingConfigStatusParams defines parameters for GetThingConfigStatus.
type GetThingConfigStatusParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// EnableThingTextBody defines parameters for EnableThing.
type EnableThingTextBody = string

// EnableThingParams defines parameters for EnableThing.
type EnableThingParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingFirmwareStatusParams defines parameters for GetThingFirmwareStatus.
type GetThingFirmwareStatusParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// UpdateThingFirmwareParams defines parameters for UpdateThingFirmware.
type UpdateThingFirmwareParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetAvailableFirmwaresForThingParams defines parameters for GetAvailableFirmwaresForThing.
type GetAvailableFirmwaresForThingParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetThingStatusParams defines parameters for GetThingStatus.
type GetThingStatusParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetRegisteredUIComponentsInNamespaceParams defines parameters for GetRegisteredUIComponentsInNamespace.
type GetRegisteredUIComponentsInNamespaceParams struct {
	// Summary summary fields only
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// StartDialogParams defines parameters for StartDialog.
type StartDialogParams struct {
	// SourceId source ID
	SourceId *string `form:"sourceId,omitempty" json:"sourceId,omitempty"`

	// KsId keywork spotter ID
	KsId *string `form:"ksId,omitempty" json:"ksId,omitempty"`

	// SttId Speech-to-Text ID
	SttId *string `form:"sttId,omitempty" json:"sttId,omitempty"`

	// TtsId Text-to-Speech ID
	TtsId *string `form:"ttsId,omitempty" json:"ttsId,omitempty"`

	// VoiceId voice ID
	VoiceId *string `form:"voiceId,omitempty" json:"voiceId,omitempty"`

	// HliIds comma separated list of interpreter IDs
	HliIds *string `form:"hliIds,omitempty" json:"hliIds,omitempty"`

	// SinkId audio sink ID
	SinkId *string `form:"sinkId,omitempty" json:"sinkId,omitempty"`

	// Keyword keyword
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// ListeningItem listening item
	ListeningItem *string `form:"listeningItem,omitempty" json:"listeningItem,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// StopDialogParams defines parameters for StopDialog.
type StopDialogParams struct {
	// SourceId source ID
	SourceId *string `form:"sourceId,omitempty" json:"sourceId,omitempty"`
}

// GetVoiceInterpretersParams defines parameters for GetVoiceInterpreters.
type GetVoiceInterpretersParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextByDefaultInterpreterTextBody defines parameters for InterpretTextByDefaultInterpreter.
type InterpretTextByDefaultInterpreterTextBody = string

// InterpretTextByDefaultInterpreterParams defines parameters for InterpretTextByDefaultInterpreter.
type InterpretTextByDefaultInterpreterParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// InterpretTextTextBody defines parameters for InterpretText.
type InterpretTextTextBody = string

// InterpretTextParams defines parameters for InterpretText.
type InterpretTextParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// GetVoiceInterpreterByUIDParams defines parameters for GetVoiceInterpreterByUID.
type GetVoiceInterpreterByUIDParams struct {
	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// ListenAndAnswerParams defines parameters for ListenAndAnswer.
type ListenAndAnswerParams struct {
	// SourceId source ID
	SourceId *string `form:"sourceId,omitempty" json:"sourceId,omitempty"`

	// SttId Speech-to-Text ID
	SttId *string `form:"sttId,omitempty" json:"sttId,omitempty"`

	// TtsId Text-to-Speech ID
	TtsId *string `form:"ttsId,omitempty" json:"ttsId,omitempty"`

	// VoiceId voice ID
	VoiceId *string `form:"voiceId,omitempty" json:"voiceId,omitempty"`

	// HliIds interpreter IDs
	HliIds *[]string `form:"hliIds,omitempty" json:"hliIds,omitempty"`

	// SinkId audio sink ID
	SinkId *string `form:"sinkId,omitempty" json:"sinkId,omitempty"`

	// ListeningItem listening item
	ListeningItem *string `form:"listeningItem,omitempty" json:"listeningItem,omitempty"`

	// AcceptLanguage language
	AcceptLanguage *string `json:"Accept-Language,omitempty"`
}

// TextToSpeechTextBody defines parameters for TextToSpeech.
type TextToSpeechTextBody = string

// TextToSpeechParams defines parameters for TextToSpeech.
type TextToSpeechParams struct {
	// Voiceid voice id
	Voiceid *string `form:"voiceid,omitempty" json:"voiceid,omitempty"`

	// Sinkid audio sink id
	Sinkid *string `form:"sinkid,omitempty" json:"sinkid,omitempty"`

	// Volume volume level
	Volume *string `form:"volume,omitempty" json:"volume,omitempty"`
}

// ExecuteThingActionJSONRequestBody defines body for ExecuteThingAction for application/json ContentType.
type ExecuteThingActionJSONRequestBody = ExecuteThingActionJSONBody

// UpdateAddonConfigurationJSONRequestBody defines body for UpdateAddonConfiguration for application/json ContentType.
type UpdateAddonConfigurationJSONRequestBody = UpdateAddonConfigurationJSONBody

// DeleteSessionFormdataRequestBody defines body for DeleteSession for application/x-www-form-urlencoded ContentType.
type DeleteSessionFormdataRequestBody DeleteSessionFormdataBody

// GetOAuthTokenFormdataRequestBody defines body for GetOAuthToken for application/x-www-form-urlencoded ContentType.
type GetOAuthTokenFormdataRequestBody GetOAuthTokenFormdataBody

// ApproveInboxItemByIdTextRequestBody defines body for ApproveInboxItemById for text/plain ContentType.
type ApproveInboxItemByIdTextRequestBody = ApproveInboxItemByIdTextBody

// AddOrUpdateItemsInRegistryJSONRequestBody defines body for AddOrUpdateItemsInRegistry for application/json ContentType.
type AddOrUpdateItemsInRegistryJSONRequestBody = AddOrUpdateItemsInRegistryJSONBody

// SendItemCommandTextRequestBody defines body for SendItemCommand for text/plain ContentType.
type SendItemCommandTextRequestBody = SendItemCommandTextBody

// AddOrUpdateItemInRegistryJSONRequestBody defines body for AddOrUpdateItemInRegistry for application/json ContentType.
type AddOrUpdateItemInRegistryJSONRequestBody = GroupItemDTO

// AddMetadataToItemJSONRequestBody defines body for AddMetadataToItem for application/json ContentType.
type AddMetadataToItemJSONRequestBody = MetadataDTO

// UpdateItemStateTextRequestBody defines body for UpdateItemState for text/plain ContentType.
type UpdateItemStateTextRequestBody = UpdateItemStateTextBody

// LinkItemToChannelJSONRequestBody defines body for LinkItemToChannel for application/json ContentType.
type LinkItemToChannelJSONRequestBody = ItemChannelLinkDTO

// PutLoggerJSONRequestBody defines body for PutLogger for application/json ContentType.
type PutLoggerJSONRequestBody = LoggerInfo

// PutPersistenceServiceConfigurationJSONRequestBody defines body for PutPersistenceServiceConfiguration for application/json ContentType.
type PutPersistenceServiceConfigurationJSONRequestBody = PersistenceServiceConfigurationDTO

// CreateRuleJSONRequestBody defines body for CreateRule for application/json ContentType.
type CreateRuleJSONRequestBody = RuleDTO

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody = RuleDTO

// UpdateRuleConfigurationJSONRequestBody defines body for UpdateRuleConfiguration for application/json ContentType.
type UpdateRuleConfigurationJSONRequestBody = UpdateRuleConfigurationJSONBody

// EnableRuleTextRequestBody defines body for EnableRule for text/plain ContentType.
type EnableRuleTextRequestBody = EnableRuleTextBody

// RunRuleNow1JSONRequestBody defines body for RunRuleNow1 for application/json ContentType.
type RunRuleNow1JSONRequestBody = RunRuleNow1JSONBody

// SetRuleModuleConfigParameterTextRequestBody defines body for SetRuleModuleConfigParameter for text/plain ContentType.
type SetRuleModuleConfigParameterTextRequestBody = SetRuleModuleConfigParameterTextBody

// UpdateServiceConfigJSONRequestBody defines body for UpdateServiceConfig for application/json ContentType.
type UpdateServiceConfigJSONRequestBody = UpdateServiceConfigJSONBody

// CreateSemanticTagJSONRequestBody defines body for CreateSemanticTag for application/json ContentType.
type CreateSemanticTagJSONRequestBody = EnrichedSemanticTagDTO

// UpdateSemanticTagJSONRequestBody defines body for UpdateSemanticTag for application/json ContentType.
type UpdateSemanticTagJSONRequestBody = EnrichedSemanticTagDTO

// CreateThingInRegistryJSONRequestBody defines body for CreateThingInRegistry for application/json ContentType.
type CreateThingInRegistryJSONRequestBody = ThingDTO

// UpdateThingJSONRequestBody defines body for UpdateThing for application/json ContentType.
type UpdateThingJSONRequestBody = ThingDTO

// UpdateThingConfigJSONRequestBody defines body for UpdateThingConfig for application/json ContentType.
type UpdateThingConfigJSONRequestBody = UpdateThingConfigJSONBody

// EnableThingTextRequestBody defines body for EnableThing for text/plain ContentType.
type EnableThingTextRequestBody = EnableThingTextBody

// PutTransformationJSONRequestBody defines body for PutTransformation for application/json ContentType.
type PutTransformationJSONRequestBody = TransformationDTO

// AddUIComponentToNamespaceJSONRequestBody defines body for AddUIComponentToNamespace for application/json ContentType.
type AddUIComponentToNamespaceJSONRequestBody = RootUIComponent

// UpdateUIComponentInNamespaceJSONRequestBody defines body for UpdateUIComponentInNamespace for application/json ContentType.
type UpdateUIComponentInNamespaceJSONRequestBody = RootUIComponent

// InterpretTextByDefaultInterpreterTextRequestBody defines body for InterpretTextByDefaultInterpreter for text/plain ContentType.
type InterpretTextByDefaultInterpreterTextRequestBody = InterpretTextByDefaultInterpreterTextBody

// InterpretTextTextRequestBody defines body for InterpretText for text/plain ContentType.
type InterpretTextTextRequestBody = InterpretTextTextBody

// TextToSpeechTextRequestBody defines body for TextToSpeech for text/plain ContentType.
type TextToSpeechTextRequestBody = TextToSpeechTextBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetRoot request
	GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableActionsForThing request
	GetAvailableActionsForThing(ctx context.Context, thingUID string, params *GetAvailableActionsForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteThingActionWithBody request with any body
	ExecuteThingActionWithBody(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteThingAction(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, body ExecuteThingActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddons request
	GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonTypes request
	GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSuggestedAddons request
	GetSuggestedAddons(ctx context.Context, params *GetSuggestedAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonServices request
	GetAddonServices(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonById request
	GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonConfiguration request
	GetAddonConfiguration(ctx context.Context, addonId string, params *GetAddonConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAddonConfigurationWithBody request with any body
	UpdateAddonConfigurationWithBody(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAddonConfiguration(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, body UpdateAddonConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallAddonById request
	InstallAddonById(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UninstallAddon request
	UninstallAddon(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSink request
	GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioDefaultSource request
	GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSinks request
	GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAudioSources request
	GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiTokens request
	GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveApiToken request
	RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSessionWithBody request with any body
	DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSessionWithFormdataBody(ctx context.Context, body DeleteSessionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionsForCurrentUser request
	GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthTokenWithBody request with any body
	GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOAuthTokenWithFormdataBody(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypes request
	GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTypeByUID request
	GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkableItemTypesByChannelTypeUID request
	GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptions request
	GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigDescriptionByURI request
	GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindingsWithDiscoverySupport request
	GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Scan request
	Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitNewStateTacker request
	InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemListForStateUpdatesWithBody request with any body
	UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGalleryWidgetList request
	GetGalleryWidgetList(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGalleryWidgetsItem request
	GetGalleryWidgetsItem(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIconSets request
	GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscoveredInboxItems request
	GetDiscoveredInboxItems(ctx context.Context, params *GetDiscoveredInboxItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromInbox request
	RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveInboxItemByIdWithBody request with any body
	ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApproveInboxItemByIdWithTextBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, body ApproveInboxItemByIdTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FlagInboxItemAsIgnored request
	FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveIgnoreFlagOnInboxItem request
	RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItems request
	GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemsInRegistryWithBody request with any body
	AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeDatabase request
	PurgeDatabase(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMemberFromGroupItem request
	RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMemberToGroupItem request
	AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSemanticItem request
	GetSemanticItem(ctx context.Context, itemName string, semanticClass string, params *GetSemanticItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveItemFromRegistry request
	RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemByName request
	GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendItemCommandWithBody request with any body
	SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendItemCommandWithTextBody(ctx context.Context, itemname string, body SendItemCommandTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrUpdateItemInRegistryWithBody request with any body
	AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemNamespaces request
	GetItemNamespaces(ctx context.Context, itemname string, params *GetItemNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMetadataFromItem request
	RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMetadataToItemWithBody request with any body
	AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemState1 request
	GetItemState1(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateItemStateWithBody request with any body
	UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateItemStateWithTextBody(ctx context.Context, itemname string, params *UpdateItemStateParams, body UpdateItemStateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTagFromItem request
	RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTagToItem request
	AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLinks request
	GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrphanLinks request
	GetOrphanLinks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeDatabase1 request
	PurgeDatabase1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnlinkItemFromChannel request
	UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemLink request
	GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkItemToChannelWithBody request with any body
	LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkItemToChannel(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveAllLinksForObject request
	RemoveAllLinksForObject(ctx context.Context, object string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogger1 request
	GetLogger1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveLogger request
	RemoveLogger(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogger request
	GetLogger(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutLoggerWithBody request with any body
	PutLoggerWithBody(ctx context.Context, loggerName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutLogger(ctx context.Context, loggerName string, body PutLoggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypes request
	GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModuleTypeById request
	GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistenceServices request
	GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemsForPersistenceService request
	GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteItemFromPersistenceService request
	DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemDataFromPersistenceService request
	GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreItemDataInPersistenceService request
	StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePersistenceServiceConfiguration request
	DeletePersistenceServiceConfiguration(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersistenceServiceConfiguration request
	GetPersistenceServiceConfiguration(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPersistenceServiceConfigurationWithBody request with any body
	PutPersistenceServiceConfigurationWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPersistenceServiceConfiguration(ctx context.Context, serviceId string, body PutPersistenceServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfileTypes request
	GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleWithBody request with any body
	CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduleRuleSimulations request
	GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleById request
	GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleWithBody request with any body
	UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleActions request
	GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConditions request
	GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleConfiguration request
	GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleConfigurationWithBody request with any body
	UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableRuleWithBody request with any body
	EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableRuleWithTextBody(ctx context.Context, ruleUID string, body EnableRuleTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunRuleNow1WithBody request with any body
	RunRuleNow1WithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunRuleNow1(ctx context.Context, ruleUID string, body RunRuleNow1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleTriggers request
	GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleById request
	GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfig request
	GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleModuleConfigParameter request
	GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRuleModuleConfigParameterWithBody request with any body
	SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRuleModuleConfigParameterWithTextBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, body SetRuleModuleConfigParameterTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesById request
	GetServicesById(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceConfig request
	DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceConfig request
	GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceConfigWithBody request with any body
	UpdateServiceConfigWithBody(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceConfig(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceContext request
	GetServiceContext(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemaps request
	GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSitemapEventSubscription request
	CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapEvents1 request
	GetSitemapEvents1(ctx context.Context, subscriptionid string, params *GetSitemapEvents1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapEvents request
	GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSitemapByName request
	GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollDataForSitemap request
	PollDataForSitemap(ctx context.Context, sitemapname string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PollDataForPage request
	PollDataForPage(ctx context.Context, sitemapname string, pageid string, params *PollDataForPageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemInformation request
	GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUoMInformation request
	GetUoMInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSemanticTags request
	GetSemanticTags(ctx context.Context, params *GetSemanticTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSemanticTagWithBody request with any body
	CreateSemanticTagWithBody(ctx context.Context, params *CreateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSemanticTag(ctx context.Context, params *CreateSemanticTagParams, body CreateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSemanticTag request
	RemoveSemanticTag(ctx context.Context, tagId string, params *RemoveSemanticTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSemanticTagAndSubTags request
	GetSemanticTagAndSubTags(ctx context.Context, tagId string, params *GetSemanticTagAndSubTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSemanticTagWithBody request with any body
	UpdateSemanticTagWithBody(ctx context.Context, tagId string, params *UpdateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSemanticTag(ctx context.Context, tagId string, params *UpdateSemanticTagParams, body UpdateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplates request
	GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTemplateById request
	GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypes request
	GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingTypeById request
	GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThings request
	GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateThingInRegistryWithBody request with any body
	CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveThingById request
	RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingById request
	GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingWithBody request with any body
	UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingConfigWithBody request with any body
	UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingConfigStatus request
	GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableThingWithBody request with any body
	EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableThingWithTextBody(ctx context.Context, thingUID string, params *EnableThingParams, body EnableThingTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingFirmwareStatus request
	GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateThingFirmware request
	UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableFirmwaresForThing request
	GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThingStatus request
	GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransformations request
	GetTransformations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransformationServices request
	GetTransformationServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransformation request
	DeleteTransformation(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransformation request
	GetTransformation(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTransformationWithBody request with any body
	PutTransformationWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTransformation(ctx context.Context, uid string, body PutTransformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegisteredUIComponentsInNamespace request
	GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUIComponentToNamespaceWithBody request with any body
	AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUIComponentToNamespace(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUIComponentFromNamespace request
	RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUIComponentInNamespace request
	GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUIComponentInNamespaceWithBody request with any body
	UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUITiles request
	GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUUID request
	GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultVoice request
	GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartDialog request
	StartDialog(ctx context.Context, params *StartDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopDialog request
	StopDialog(ctx context.Context, params *StopDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreters request
	GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretTextByDefaultInterpreterWithBody request with any body
	InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InterpretTextByDefaultInterpreterWithTextBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, body InterpretTextByDefaultInterpreterTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InterpretTextWithBody request with any body
	InterpretTextWithBody(ctx context.Context, ids []string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InterpretTextWithTextBody(ctx context.Context, ids []string, params *InterpretTextParams, body InterpretTextTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoiceInterpreterByUID request
	GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListenAndAnswer request
	ListenAndAnswer(ctx context.Context, params *ListenAndAnswerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TextToSpeechWithBody request with any body
	TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TextToSpeechWithTextBody(ctx context.Context, params *TextToSpeechParams, body TextToSpeechTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoices request
	GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableActionsForThing(ctx context.Context, thingUID string, params *GetAvailableActionsForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableActionsForThingRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteThingActionWithBody(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteThingActionRequestWithBody(c.Server, thingUID, actionUid, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteThingAction(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, body ExecuteThingActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteThingActionRequest(c.Server, thingUID, actionUid, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddons(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonTypes(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSuggestedAddons(ctx context.Context, params *GetSuggestedAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSuggestedAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonServices(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonById(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonByIdRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonConfiguration(ctx context.Context, addonId string, params *GetAddonConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonConfigurationRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonConfigurationWithBody(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonConfigurationRequestWithBody(c.Server, addonId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonConfiguration(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, body UpdateAddonConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonConfigurationRequest(c.Server, addonId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallAddonById(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallAddonByIdRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UninstallAddon(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUninstallAddonRequest(c.Server, addonId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSink(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioDefaultSource(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioDefaultSourceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSinks(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAudioSources(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAudioSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveApiToken(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveApiTokenRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSessionWithFormdataBody(ctx context.Context, body DeleteSessionFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionsForCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionsForCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithFormdataBody(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypes(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTypeByUID(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTypeByUIDRequest(c.Server, channelTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkableItemTypesByChannelTypeUID(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkableItemTypesByChannelTypeUIDRequest(c.Server, channelTypeUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptions(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigDescriptionByURI(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigDescriptionByURIRequest(c.Server, uri, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindingsWithDiscoverySupport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindingsWithDiscoverySupportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Scan(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScanRequest(c.Server, bindingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitNewStateTacker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitNewStateTackerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemListForStateUpdatesWithBody(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemListForStateUpdatesRequestWithBody(c.Server, connectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGalleryWidgetList(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGalleryWidgetListRequest(c.Server, galleryName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGalleryWidgetsItem(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGalleryWidgetsItemRequest(c.Server, galleryName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIconSets(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIconSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscoveredInboxItems(ctx context.Context, params *GetDiscoveredInboxItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscoveredInboxItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromInbox(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromInboxRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveInboxItemByIdWithBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveInboxItemByIdRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveInboxItemByIdWithTextBody(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, body ApproveInboxItemByIdTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveInboxItemByIdRequestWithTextBody(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FlagInboxItemAsIgnored(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFlagInboxItemAsIgnoredRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveIgnoreFlagOnInboxItem(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveIgnoreFlagOnInboxItemRequest(c.Server, thingUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItems(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemsInRegistry(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemsInRegistryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeDatabase(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeDatabaseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMemberFromGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMemberFromGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMemberToGroupItem(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMemberToGroupItemRequest(c.Server, itemName, memberItemName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSemanticItem(ctx context.Context, itemName string, semanticClass string, params *GetSemanticItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSemanticItemRequest(c.Server, itemName, semanticClass, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveItemFromRegistry(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveItemFromRegistryRequest(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemByName(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemByNameRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendItemCommandWithBody(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendItemCommandRequestWithBody(c.Server, itemname, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendItemCommandWithTextBody(ctx context.Context, itemname string, body SendItemCommandTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendItemCommandRequestWithTextBody(c.Server, itemname, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistryWithBody(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrUpdateItemInRegistry(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrUpdateItemInRegistryRequest(c.Server, itemname, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemNamespaces(ctx context.Context, itemname string, params *GetItemNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemNamespacesRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMetadataFromItem(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMetadataFromItemRequest(c.Server, itemname, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItemWithBody(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequestWithBody(c.Server, itemname, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMetadataToItem(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMetadataToItemRequest(c.Server, itemname, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemState1(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemState1Request(c.Server, itemname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemStateWithBody(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemStateRequestWithBody(c.Server, itemname, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateItemStateWithTextBody(ctx context.Context, itemname string, params *UpdateItemStateParams, body UpdateItemStateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateItemStateRequestWithTextBody(c.Server, itemname, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTagFromItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTagFromItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTagToItem(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTagToItemRequest(c.Server, itemname, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLinks(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrphanLinks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrphanLinksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeDatabase1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeDatabase1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnlinkItemFromChannel(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnlinkItemFromChannelRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemLink(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemLinkRequest(c.Server, itemName, channelUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkItemToChannelWithBody(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkItemToChannelRequestWithBody(c.Server, itemName, channelUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkItemToChannel(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkItemToChannelRequest(c.Server, itemName, channelUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveAllLinksForObject(ctx context.Context, object string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveAllLinksForObjectRequest(c.Server, object)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogger1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogger1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveLogger(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveLoggerRequest(c.Server, loggerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogger(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggerRequest(c.Server, loggerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLoggerWithBody(ctx context.Context, loggerName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLoggerRequestWithBody(c.Server, loggerName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutLogger(ctx context.Context, loggerName string, body PutLoggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutLoggerRequest(c.Server, loggerName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypes(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModuleTypeById(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModuleTypeByIdRequest(c.Server, moduleTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistenceServices(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemsForPersistenceService(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsForPersistenceServiceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteItemFromPersistenceService(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteItemFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemDataFromPersistenceService(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemDataFromPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreItemDataInPersistenceService(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreItemDataInPersistenceServiceRequest(c.Server, itemname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePersistenceServiceConfiguration(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePersistenceServiceConfigurationRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersistenceServiceConfiguration(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersistenceServiceConfigurationRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPersistenceServiceConfigurationWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPersistenceServiceConfigurationRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPersistenceServiceConfiguration(ctx context.Context, serviceId string, body PutPersistenceServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPersistenceServiceConfigurationRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfileTypes(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduleRuleSimulations(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRuleSimulationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleById(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleByIdRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleActions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleActionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConditions(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConditionsRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleConfiguration(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleConfigurationRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfigurationWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleConfiguration(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleConfigurationRequest(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableRuleWithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableRuleRequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableRuleWithTextBody(ctx context.Context, ruleUID string, body EnableRuleTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableRuleRequestWithTextBody(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRuleNow1WithBody(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRuleNow1RequestWithBody(c.Server, ruleUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunRuleNow1(ctx context.Context, ruleUID string, body RunRuleNow1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunRuleNow1Request(c.Server, ruleUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleTriggers(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleTriggersRequest(c.Server, ruleUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleById(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleByIdRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfig(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigRequest(c.Server, ruleUID, moduleCategory, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleModuleConfigParameter(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleModuleConfigParameterRequest(c.Server, ruleUID, moduleCategory, id, param)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRuleModuleConfigParameterWithBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRuleModuleConfigParameterRequestWithBody(c.Server, ruleUID, moduleCategory, id, param, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRuleModuleConfigParameterWithTextBody(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, body SetRuleModuleConfigParameterTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRuleModuleConfigParameterRequestWithTextBody(c.Server, ruleUID, moduleCategory, id, param, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesById(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesByIdRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceConfig(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceConfigRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfigWithBody(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequestWithBody(c.Server, serviceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceConfig(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceConfigRequest(c.Server, serviceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceContext(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceContextRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemaps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSitemapEventSubscription(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSitemapEventSubscriptionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapEvents1(ctx context.Context, subscriptionid string, params *GetSitemapEvents1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapEvents1Request(c.Server, subscriptionid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapEvents(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapEventsRequest(c.Server, subscriptionid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSitemapByName(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitemapByNameRequest(c.Server, sitemapname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollDataForSitemap(ctx context.Context, sitemapname string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollDataForSitemapRequest(c.Server, sitemapname, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PollDataForPage(ctx context.Context, sitemapname string, pageid string, params *PollDataForPageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPollDataForPageRequest(c.Server, sitemapname, pageid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUoMInformation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUoMInformationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSemanticTags(ctx context.Context, params *GetSemanticTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSemanticTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSemanticTagWithBody(ctx context.Context, params *CreateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSemanticTagRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSemanticTag(ctx context.Context, params *CreateSemanticTagParams, body CreateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSemanticTagRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSemanticTag(ctx context.Context, tagId string, params *RemoveSemanticTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSemanticTagRequest(c.Server, tagId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSemanticTagAndSubTags(ctx context.Context, tagId string, params *GetSemanticTagAndSubTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSemanticTagAndSubTagsRequest(c.Server, tagId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSemanticTagWithBody(ctx context.Context, tagId string, params *UpdateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSemanticTagRequestWithBody(c.Server, tagId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSemanticTag(ctx context.Context, tagId string, params *UpdateSemanticTagParams, body UpdateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSemanticTagRequest(c.Server, tagId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplates(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTemplateById(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTemplateByIdRequest(c.Server, templateUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypes(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingTypeById(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingTypeByIdRequest(c.Server, thingTypeUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThings(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistryWithBody(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThingInRegistry(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThingInRegistryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveThingById(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingById(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingByIdRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingWithBody(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThing(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfigWithBody(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingConfig(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingConfigRequest(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingConfigStatus(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingConfigStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableThingWithBody(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableThingRequestWithBody(c.Server, thingUID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableThingWithTextBody(ctx context.Context, thingUID string, params *EnableThingParams, body EnableThingTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableThingRequestWithTextBody(c.Server, thingUID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingFirmwareStatus(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingFirmwareStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateThingFirmware(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateThingFirmwareRequest(c.Server, thingUID, firmwareVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableFirmwaresForThing(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableFirmwaresForThingRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThingStatus(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThingStatusRequest(c.Server, thingUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransformations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransformationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransformationServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransformationServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransformation(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransformationRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransformation(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransformationRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTransformationWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTransformationRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTransformation(ctx context.Context, uid string, body PutTransformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTransformationRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegisteredUIComponentsInNamespace(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegisteredUIComponentsInNamespaceRequest(c.Server, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUIComponentToNamespaceWithBody(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUIComponentToNamespaceRequestWithBody(c.Server, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUIComponentToNamespace(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUIComponentToNamespaceRequest(c.Server, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUIComponentFromNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUIComponentFromNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUIComponentInNamespaceRequest(c.Server, namespace, componentUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUIComponentInNamespaceWithBody(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUIComponentInNamespaceRequestWithBody(c.Server, namespace, componentUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUIComponentInNamespace(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUIComponentInNamespaceRequest(c.Server, namespace, componentUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUITiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUITilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUUID(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUUIDRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultVoice(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultVoiceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartDialog(ctx context.Context, params *StartDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopDialog(ctx context.Context, params *StopDialogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopDialogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreters(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpretersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextByDefaultInterpreterWithBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextByDefaultInterpreterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextByDefaultInterpreterWithTextBody(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, body InterpretTextByDefaultInterpreterTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextByDefaultInterpreterRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextWithBody(ctx context.Context, ids []string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextRequestWithBody(c.Server, ids, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InterpretTextWithTextBody(ctx context.Context, ids []string, params *InterpretTextParams, body InterpretTextTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInterpretTextRequestWithTextBody(c.Server, ids, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoiceInterpreterByUID(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoiceInterpreterByUIDRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListenAndAnswer(ctx context.Context, params *ListenAndAnswerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenAndAnswerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TextToSpeechWithBody(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTextToSpeechRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TextToSpeechWithTextBody(ctx context.Context, params *TextToSpeechParams, body TextToSpeechTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTextToSpeechRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetRootRequest generates requests for GetRoot
func NewGetRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAvailableActionsForThingRequest generates requests for GetAvailableActionsForThing
func NewGetAvailableActionsForThingRequest(server string, thingUID string, params *GetAvailableActionsForThingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/actions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewExecuteThingActionRequest calls the generic ExecuteThingAction builder with application/json body
func NewExecuteThingActionRequest(server string, thingUID string, actionUid string, params *ExecuteThingActionParams, body ExecuteThingActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteThingActionRequestWithBody(server, thingUID, actionUid, params, "application/json", bodyReader)
}

// NewExecuteThingActionRequestWithBody generates requests for ExecuteThingAction with any type of body
func NewExecuteThingActionRequestWithBody(server string, thingUID string, actionUid string, params *ExecuteThingActionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "actionUid", runtime.ParamLocationPath, actionUid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/actions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAddonsRequest generates requests for GetAddons
func NewGetAddonsRequest(server string, params *GetAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAddonTypesRequest generates requests for GetAddonTypes
func NewGetAddonTypesRequest(server string, params *GetAddonTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSuggestedAddonsRequest generates requests for GetSuggestedAddons
func NewGetSuggestedAddonsRequest(server string, params *GetSuggestedAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/suggestions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAddonServicesRequest generates requests for GetAddonServices
func NewGetAddonServicesRequest(server string, params *GetAddonServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAddonByIdRequest generates requests for GetAddonById
func NewGetAddonByIdRequest(server string, addonId string, params *GetAddonByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAddonConfigurationRequest generates requests for GetAddonConfiguration
func NewGetAddonConfigurationRequest(server string, addonId string, params *GetAddonConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAddonConfigurationRequest calls the generic UpdateAddonConfiguration builder with application/json body
func NewUpdateAddonConfigurationRequest(server string, addonId string, params *UpdateAddonConfigurationParams, body UpdateAddonConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAddonConfigurationRequestWithBody(server, addonId, params, "application/json", bodyReader)
}

// NewUpdateAddonConfigurationRequestWithBody generates requests for UpdateAddonConfiguration with any type of body
func NewUpdateAddonConfigurationRequestWithBody(server string, addonId string, params *UpdateAddonConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallAddonByIdRequest generates requests for InstallAddonById
func NewInstallAddonByIdRequest(server string, addonId string, params *InstallAddonByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/install", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUninstallAddonRequest generates requests for UninstallAddon
func NewUninstallAddonRequest(server string, addonId string, params *UninstallAddonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "addonId", runtime.ParamLocationPath, addonId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/uninstall", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAudioDefaultSinkRequest generates requests for GetAudioDefaultSink
func NewGetAudioDefaultSinkRequest(server string, params *GetAudioDefaultSinkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAudioDefaultSourceRequest generates requests for GetAudioDefaultSource
func NewGetAudioDefaultSourceRequest(server string, params *GetAudioDefaultSourceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/defaultsource")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAudioSinksRequest generates requests for GetAudioSinks
func NewGetAudioSinksRequest(server string, params *GetAudioSinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sinks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAudioSourcesRequest generates requests for GetAudioSources
func NewGetAudioSourcesRequest(server string, params *GetAudioSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiTokensRequest generates requests for GetApiTokens
func NewGetApiTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveApiTokenRequest generates requests for RemoveApiToken
func NewRemoveApiTokenRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/apitokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSessionRequestWithFormdataBody calls the generic DeleteSession builder with application/x-www-form-urlencoded body
func NewDeleteSessionRequestWithFormdataBody(server string, body DeleteSessionFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewDeleteSessionRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewDeleteSessionRequestWithBody generates requests for DeleteSession with any type of body
func NewDeleteSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSessionsForCurrentUserRequest generates requests for GetSessionsForCurrentUser
func NewGetSessionsForCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthTokenRequestWithFormdataBody calls the generic GetOAuthToken builder with application/x-www-form-urlencoded body
func NewGetOAuthTokenRequestWithFormdataBody(server string, params *GetOAuthTokenParams, body GetOAuthTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGetOAuthTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, params *GetOAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UseCookie != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "useCookie", runtime.ParamLocationQuery, *params.UseCookie); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelTypesRequest generates requests for GetChannelTypes
func NewGetChannelTypesRequest(server string, params *GetChannelTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefixes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetChannelTypeByUIDRequest generates requests for GetChannelTypeByUID
func NewGetChannelTypeByUIDRequest(server string, channelTypeUID string, params *GetChannelTypeByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetLinkableItemTypesByChannelTypeUIDRequest generates requests for GetLinkableItemTypesByChannelTypeUID
func NewGetLinkableItemTypesByChannelTypeUIDRequest(server string, channelTypeUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelTypeUID", runtime.ParamLocationPath, channelTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel-types/%s/linkableItemTypes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigDescriptionsRequest generates requests for GetConfigDescriptions
func NewGetConfigDescriptionsRequest(server string, params *GetConfigDescriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Scheme != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheme", runtime.ParamLocationQuery, *params.Scheme); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetConfigDescriptionByURIRequest generates requests for GetConfigDescriptionByURI
func NewGetConfigDescriptionByURIRequest(server string, uri string, params *GetConfigDescriptionByURIParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uri", runtime.ParamLocationPath, uri)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config-descriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetBindingsWithDiscoverySupportRequest generates requests for GetBindingsWithDiscoverySupport
func NewGetBindingsWithDiscoverySupportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScanRequest generates requests for Scan
func NewScanRequest(server string, bindingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bindingId", runtime.ParamLocationPath, bindingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/bindings/%s/scan", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, params *GetEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Topics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitNewStateTackerRequest generates requests for InitNewStateTacker
func NewInitNewStateTackerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemListForStateUpdatesRequestWithBody generates requests for UpdateItemListForStateUpdates with any type of body
func NewUpdateItemListForStateUpdatesRequestWithBody(server string, connectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectionId", runtime.ParamLocationPath, connectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/states/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGalleryWidgetListRequest generates requests for GetGalleryWidgetList
func NewGetGalleryWidgetListRequest(server string, galleryName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, galleryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/habpanel/gallery/%s/widgets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGalleryWidgetsItemRequest generates requests for GetGalleryWidgetsItem
func NewGetGalleryWidgetsItemRequest(server string, galleryName string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "galleryName", runtime.ParamLocationPath, galleryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/habpanel/gallery/%s/widgets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIconSetsRequest generates requests for GetIconSets
func NewGetIconSetsRequest(server string, params *GetIconSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iconsets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetDiscoveredInboxItemsRequest generates requests for GetDiscoveredInboxItems
func NewGetDiscoveredInboxItemsRequest(server string, params *GetDiscoveredInboxItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeIgnored != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeIgnored", runtime.ParamLocationQuery, *params.IncludeIgnored); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveItemFromInboxRequest generates requests for RemoveItemFromInbox
func NewRemoveItemFromInboxRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApproveInboxItemByIdRequestWithTextBody calls the generic ApproveInboxItemById builder with text/plain body
func NewApproveInboxItemByIdRequestWithTextBody(server string, thingUID string, params *ApproveInboxItemByIdParams, body ApproveInboxItemByIdTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewApproveInboxItemByIdRequestWithBody(server, thingUID, params, "text/plain", bodyReader)
}

// NewApproveInboxItemByIdRequestWithBody generates requests for ApproveInboxItemById with any type of body
func NewApproveInboxItemByIdRequestWithBody(server string, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewThingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newThingId", runtime.ParamLocationQuery, *params.NewThingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewFlagInboxItemAsIgnoredRequest generates requests for FlagInboxItemAsIgnored
func NewFlagInboxItemAsIgnoredRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/ignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveIgnoreFlagOnInboxItemRequest generates requests for RemoveIgnoreFlagOnInboxItem
func NewRemoveIgnoreFlagOnInboxItemRequest(server string, thingUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inbox/%s/unignore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemsRequest generates requests for GetItems
func NewGetItemsRequest(server string, params *GetItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticDataOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticDataOnly", runtime.ParamLocationQuery, *params.StaticDataOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewAddOrUpdateItemsInRegistryRequest calls the generic AddOrUpdateItemsInRegistry builder with application/json body
func NewAddOrUpdateItemsInRegistryRequest(server string, body AddOrUpdateItemsInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemsInRegistryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrUpdateItemsInRegistryRequestWithBody generates requests for AddOrUpdateItemsInRegistry with any type of body
func NewAddOrUpdateItemsInRegistryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPurgeDatabaseRequest generates requests for PurgeDatabase
func NewPurgeDatabaseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/metadata/purge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveMemberFromGroupItemRequest generates requests for RemoveMemberFromGroupItem
func NewRemoveMemberFromGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMemberToGroupItemRequest generates requests for AddMemberToGroupItem
func NewAddMemberToGroupItemRequest(server string, itemName string, memberItemName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "memberItemName", runtime.ParamLocationPath, memberItemName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSemanticItemRequest generates requests for GetSemanticItem
func NewGetSemanticItemRequest(server string, itemName string, semanticClass string, params *GetSemanticItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "semanticClass", runtime.ParamLocationPath, semanticClass)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/semantic/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveItemFromRegistryRequest generates requests for RemoveItemFromRegistry
func NewRemoveItemFromRegistryRequest(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemByNameRequest generates requests for GetItemByName
func NewGetItemByNameRequest(server string, itemname string, params *GetItemByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSendItemCommandRequestWithTextBody calls the generic SendItemCommand builder with text/plain body
func NewSendItemCommandRequestWithTextBody(server string, itemname string, body SendItemCommandTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewSendItemCommandRequestWithBody(server, itemname, "text/plain", bodyReader)
}

// NewSendItemCommandRequestWithBody generates requests for SendItemCommand with any type of body
func NewSendItemCommandRequestWithBody(server string, itemname string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOrUpdateItemInRegistryRequest calls the generic AddOrUpdateItemInRegistry builder with application/json body
func NewAddOrUpdateItemInRegistryRequest(server string, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrUpdateItemInRegistryRequestWithBody(server, itemname, params, "application/json", bodyReader)
}

// NewAddOrUpdateItemInRegistryRequestWithBody generates requests for AddOrUpdateItemInRegistry with any type of body
func NewAddOrUpdateItemInRegistryRequestWithBody(server string, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetItemNamespacesRequest generates requests for GetItemNamespaces
func NewGetItemNamespacesRequest(server string, itemname string, params *GetItemNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/namespaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveMetadataFromItemRequest generates requests for RemoveMetadataFromItem
func NewRemoveMetadataFromItemRequest(server string, itemname string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMetadataToItemRequest calls the generic AddMetadataToItem builder with application/json body
func NewAddMetadataToItemRequest(server string, itemname string, namespace string, body AddMetadataToItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMetadataToItemRequestWithBody(server, itemname, namespace, "application/json", bodyReader)
}

// NewAddMetadataToItemRequestWithBody generates requests for AddMetadataToItem with any type of body
func NewAddMetadataToItemRequestWithBody(server string, itemname string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/metadata/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetItemState1Request generates requests for GetItemState1
func NewGetItemState1Request(server string, itemname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateItemStateRequestWithTextBody calls the generic UpdateItemState builder with text/plain body
func NewUpdateItemStateRequestWithTextBody(server string, itemname string, params *UpdateItemStateParams, body UpdateItemStateTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewUpdateItemStateRequestWithBody(server, itemname, params, "text/plain", bodyReader)
}

// NewUpdateItemStateRequestWithBody generates requests for UpdateItemState with any type of body
func NewUpdateItemStateRequestWithBody(server string, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveTagFromItemRequest generates requests for RemoveTagFromItem
func NewRemoveTagFromItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTagToItemRequest generates requests for AddTagToItem
func NewAddTagToItemRequest(server string, itemname string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinksRequest generates requests for GetItemLinks
func NewGetItemLinksRequest(server string, params *GetItemLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelUID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelUID", runtime.ParamLocationQuery, *params.ChannelUID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemName", runtime.ParamLocationQuery, *params.ItemName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrphanLinksRequest generates requests for GetOrphanLinks
func NewGetOrphanLinksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/orphans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPurgeDatabase1Request generates requests for PurgeDatabase1
func NewPurgeDatabase1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/purge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnlinkItemFromChannelRequest generates requests for UnlinkItemFromChannel
func NewUnlinkItemFromChannelRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemLinkRequest generates requests for GetItemLink
func NewGetItemLinkRequest(server string, itemName string, channelUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkItemToChannelRequest calls the generic LinkItemToChannel builder with application/json body
func NewLinkItemToChannelRequest(server string, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkItemToChannelRequestWithBody(server, itemName, channelUID, "application/json", bodyReader)
}

// NewLinkItemToChannelRequestWithBody generates requests for LinkItemToChannel with any type of body
func NewLinkItemToChannelRequestWithBody(server string, itemName string, channelUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemName", runtime.ParamLocationPath, itemName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channelUID", runtime.ParamLocationPath, channelUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveAllLinksForObjectRequest generates requests for RemoveAllLinksForObject
func NewRemoveAllLinksForObjectRequest(server string, object string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object", runtime.ParamLocationPath, object)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/links/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogger1Request generates requests for GetLogger1
func NewGetLogger1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logging")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveLoggerRequest generates requests for RemoveLogger
func NewRemoveLoggerRequest(server string, loggerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loggerName", runtime.ParamLocationPath, loggerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logging/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggerRequest generates requests for GetLogger
func NewGetLoggerRequest(server string, loggerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loggerName", runtime.ParamLocationPath, loggerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logging/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutLoggerRequest calls the generic PutLogger builder with application/json body
func NewPutLoggerRequest(server string, loggerName string, body PutLoggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutLoggerRequestWithBody(server, loggerName, "application/json", bodyReader)
}

// NewPutLoggerRequestWithBody generates requests for PutLogger with any type of body
func NewPutLoggerRequestWithBody(server string, loggerName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "loggerName", runtime.ParamLocationPath, loggerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logging/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetModuleTypesRequest generates requests for GetModuleTypes
func NewGetModuleTypesRequest(server string, params *GetModuleTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetModuleTypeByIdRequest generates requests for GetModuleTypeById
func NewGetModuleTypeByIdRequest(server string, moduleTypeUID string, params *GetModuleTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "moduleTypeUID", runtime.ParamLocationPath, moduleTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/module-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetPersistenceServicesRequest generates requests for GetPersistenceServices
func NewGetPersistenceServicesRequest(server string, params *GetPersistenceServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetItemsForPersistenceServiceRequest generates requests for GetItemsForPersistenceService
func NewGetItemsForPersistenceServiceRequest(server string, params *GetItemsForPersistenceServiceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteItemFromPersistenceServiceRequest generates requests for DeleteItemFromPersistenceService
func NewDeleteItemFromPersistenceServiceRequest(server string, itemname string, params *DeleteItemFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, params.ServiceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, params.Starttime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, params.Endtime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemDataFromPersistenceServiceRequest generates requests for GetItemDataFromPersistenceService
func NewGetItemDataFromPersistenceServiceRequest(server string, itemname string, params *GetItemDataFromPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Starttime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starttime", runtime.ParamLocationQuery, *params.Starttime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Endtime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endtime", runtime.ParamLocationQuery, *params.Endtime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pagelength != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagelength", runtime.ParamLocationQuery, *params.Pagelength); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Boundary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boundary", runtime.ParamLocationQuery, *params.Boundary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreItemDataInPersistenceServiceRequest generates requests for StoreItemDataInPersistenceService
func NewStoreItemDataInPersistenceServiceRequest(server string, itemname string, params *StoreItemDataInPersistenceServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemname", runtime.ParamLocationPath, itemname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ServiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceId", runtime.ParamLocationQuery, *params.ServiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, params.Time); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePersistenceServiceConfigurationRequest generates requests for DeletePersistenceServiceConfiguration
func NewDeletePersistenceServiceConfigurationRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersistenceServiceConfigurationRequest generates requests for GetPersistenceServiceConfiguration
func NewGetPersistenceServiceConfigurationRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPersistenceServiceConfigurationRequest calls the generic PutPersistenceServiceConfiguration builder with application/json body
func NewPutPersistenceServiceConfigurationRequest(server string, serviceId string, body PutPersistenceServiceConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPersistenceServiceConfigurationRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewPutPersistenceServiceConfigurationRequestWithBody generates requests for PutPersistenceServiceConfiguration with any type of body
func NewPutPersistenceServiceConfigurationRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistence/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProfileTypesRequest generates requests for GetProfileTypes
func NewGetProfileTypesRequest(server string, params *GetProfileTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ChannelTypeUID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelTypeUID", runtime.ParamLocationQuery, *params.ChannelTypeUID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ItemType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "itemType", runtime.ParamLocationQuery, *params.ItemType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticDataOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticDataOnly", runtime.ParamLocationQuery, *params.StaticDataOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScheduleRuleSimulationsRequest generates requests for GetScheduleRuleSimulations
func NewGetScheduleRuleSimulationsRequest(server string, params *GetScheduleRuleSimulationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/schedule/simulations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleByIdRequest generates requests for GetRuleById
func NewGetRuleByIdRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, ruleUID string, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRuleActionsRequest generates requests for GetRuleActions
func NewGetRuleActionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConditionsRequest generates requests for GetRuleConditions
func NewGetRuleConditionsRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleConfigurationRequest generates requests for GetRuleConfiguration
func NewGetRuleConfigurationRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleConfigurationRequest calls the generic UpdateRuleConfiguration builder with application/json body
func NewUpdateRuleConfigurationRequest(server string, ruleUID string, body UpdateRuleConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleConfigurationRequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewUpdateRuleConfigurationRequestWithBody generates requests for UpdateRuleConfiguration with any type of body
func NewUpdateRuleConfigurationRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableRuleRequestWithTextBody calls the generic EnableRule builder with text/plain body
func NewEnableRuleRequestWithTextBody(server string, ruleUID string, body EnableRuleTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewEnableRuleRequestWithBody(server, ruleUID, "text/plain", bodyReader)
}

// NewEnableRuleRequestWithBody generates requests for EnableRule with any type of body
func NewEnableRuleRequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunRuleNow1Request calls the generic RunRuleNow1 builder with application/json body
func NewRunRuleNow1Request(server string, ruleUID string, body RunRuleNow1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunRuleNow1RequestWithBody(server, ruleUID, "application/json", bodyReader)
}

// NewRunRuleNow1RequestWithBody generates requests for RunRuleNow1 with any type of body
func NewRunRuleNow1RequestWithBody(server string, ruleUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/runnow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRuleTriggersRequest generates requests for GetRuleTriggers
func NewGetRuleTriggersRequest(server string, ruleUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleByIdRequest generates requests for GetRuleModuleById
func NewGetRuleModuleByIdRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigRequest generates requests for GetRuleModuleConfig
func NewGetRuleModuleConfigRequest(server string, ruleUID string, moduleCategory string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleModuleConfigParameterRequest generates requests for GetRuleModuleConfigParameter
func NewGetRuleModuleConfigParameterRequest(server string, ruleUID string, moduleCategory string, id string, param string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRuleModuleConfigParameterRequestWithTextBody calls the generic SetRuleModuleConfigParameter builder with text/plain body
func NewSetRuleModuleConfigParameterRequestWithTextBody(server string, ruleUID string, moduleCategory string, id string, param string, body SetRuleModuleConfigParameterTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewSetRuleModuleConfigParameterRequestWithBody(server, ruleUID, moduleCategory, id, param, "text/plain", bodyReader)
}

// NewSetRuleModuleConfigParameterRequestWithBody generates requests for SetRuleModuleConfigParameter with any type of body
func NewSetRuleModuleConfigParameterRequestWithBody(server string, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleUID", runtime.ParamLocationPath, ruleUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "moduleCategory", runtime.ParamLocationPath, moduleCategory)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "param", runtime.ParamLocationPath, param)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/%s/%s/config/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string, params *GetServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetServicesByIdRequest generates requests for GetServicesById
func NewGetServicesByIdRequest(server string, serviceId string, params *GetServicesByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteServiceConfigRequest generates requests for DeleteServiceConfig
func NewDeleteServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceConfigRequest generates requests for GetServiceConfig
func NewGetServiceConfigRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceConfigRequest calls the generic UpdateServiceConfig builder with application/json body
func NewUpdateServiceConfigRequest(server string, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceConfigRequestWithBody(server, serviceId, params, "application/json", bodyReader)
}

// NewUpdateServiceConfigRequestWithBody generates requests for UpdateServiceConfig with any type of body
func NewUpdateServiceConfigRequestWithBody(server string, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetServiceContextRequest generates requests for GetServiceContext
func NewGetServiceContextRequest(server string, serviceId string, params *GetServiceContextParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/contexts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSitemapsRequest generates requests for GetSitemaps
func NewGetSitemapsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSitemapEventSubscriptionRequest generates requests for CreateSitemapEventSubscription
func NewCreateSitemapEventSubscriptionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/subscribe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapEvents1Request generates requests for GetSitemapEvents1
func NewGetSitemapEvents1Request(server string, subscriptionid string, params *GetSitemapEvents1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionid", runtime.ParamLocationPath, subscriptionid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sitemap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitemap", runtime.ParamLocationQuery, *params.Sitemap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pageid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageid", runtime.ParamLocationQuery, *params.Pageid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapEventsRequest generates requests for GetSitemapEvents
func NewGetSitemapEventsRequest(server string, subscriptionid string, params *GetSitemapEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionid", runtime.ParamLocationPath, subscriptionid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/events/%s/*", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sitemap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sitemap", runtime.ParamLocationQuery, *params.Sitemap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSitemapByNameRequest generates requests for GetSitemapByName
func NewGetSitemapByNameRequest(server string, sitemapname string, params *GetSitemapByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jsoncallback != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsoncallback", runtime.ParamLocationQuery, *params.Jsoncallback); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewPollDataForSitemapRequest generates requests for PollDataForSitemap
func NewPollDataForSitemapRequest(server string, sitemapname string, params *PollDataForSitemapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s/*", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Subscriptionid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionid", runtime.ParamLocationQuery, *params.Subscriptionid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewPollDataForPageRequest generates requests for PollDataForPage
func NewPollDataForPageRequest(server string, sitemapname string, pageid string, params *PollDataForPageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sitemapname", runtime.ParamLocationPath, sitemapname)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pageid", runtime.ParamLocationPath, pageid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sitemaps/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Subscriptionid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionid", runtime.ParamLocationQuery, *params.Subscriptionid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeHidden", runtime.ParamLocationQuery, *params.IncludeHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSystemInformationRequest generates requests for GetSystemInformation
func NewGetSystemInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systeminfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUoMInformationRequest generates requests for GetUoMInformation
func NewGetUoMInformationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systeminfo/uom")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSemanticTagsRequest generates requests for GetSemanticTags
func NewGetSemanticTagsRequest(server string, params *GetSemanticTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSemanticTagRequest calls the generic CreateSemanticTag builder with application/json body
func NewCreateSemanticTagRequest(server string, params *CreateSemanticTagParams, body CreateSemanticTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSemanticTagRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSemanticTagRequestWithBody generates requests for CreateSemanticTag with any type of body
func NewCreateSemanticTagRequestWithBody(server string, params *CreateSemanticTagParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveSemanticTagRequest generates requests for RemoveSemanticTag
func NewRemoveSemanticTagRequest(server string, tagId string, params *RemoveSemanticTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSemanticTagAndSubTagsRequest generates requests for GetSemanticTagAndSubTags
func NewGetSemanticTagAndSubTagsRequest(server string, tagId string, params *GetSemanticTagAndSubTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSemanticTagRequest calls the generic UpdateSemanticTag builder with application/json body
func NewUpdateSemanticTagRequest(server string, tagId string, params *UpdateSemanticTagParams, body UpdateSemanticTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSemanticTagRequestWithBody(server, tagId, params, "application/json", bodyReader)
}

// NewUpdateSemanticTagRequestWithBody generates requests for UpdateSemanticTag with any type of body
func NewUpdateSemanticTagRequestWithBody(server string, tagId string, params *UpdateSemanticTagParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetTemplatesRequest generates requests for GetTemplates
func NewGetTemplatesRequest(server string, params *GetTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetTemplateByIdRequest generates requests for GetTemplateById
func NewGetTemplateByIdRequest(server string, templateUID string, params *GetTemplateByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateUID", runtime.ParamLocationPath, templateUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingTypesRequest generates requests for GetThingTypes
func NewGetThingTypesRequest(server string, params *GetThingTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BindingId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bindingId", runtime.ParamLocationQuery, *params.BindingId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingTypeByIdRequest generates requests for GetThingTypeById
func NewGetThingTypeByIdRequest(server string, thingTypeUID string, params *GetThingTypeByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingTypeUID", runtime.ParamLocationPath, thingTypeUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thing-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingsRequest generates requests for GetThings
func NewGetThingsRequest(server string, params *GetThingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StaticDataOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staticDataOnly", runtime.ParamLocationQuery, *params.StaticDataOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewCreateThingInRegistryRequest calls the generic CreateThingInRegistry builder with application/json body
func NewCreateThingInRegistryRequest(server string, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateThingInRegistryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateThingInRegistryRequestWithBody generates requests for CreateThingInRegistry with any type of body
func NewCreateThingInRegistryRequestWithBody(server string, params *CreateThingInRegistryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewRemoveThingByIdRequest generates requests for RemoveThingById
func NewRemoveThingByIdRequest(server string, thingUID string, params *RemoveThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingByIdRequest generates requests for GetThingById
func NewGetThingByIdRequest(server string, thingUID string, params *GetThingByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateThingRequest calls the generic UpdateThing builder with application/json body
func NewUpdateThingRequest(server string, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingRequestWithBody generates requests for UpdateThing with any type of body
func NewUpdateThingRequestWithBody(server string, thingUID string, params *UpdateThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateThingConfigRequest calls the generic UpdateThingConfig builder with application/json body
func NewUpdateThingConfigRequest(server string, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateThingConfigRequestWithBody(server, thingUID, params, "application/json", bodyReader)
}

// NewUpdateThingConfigRequestWithBody generates requests for UpdateThingConfig with any type of body
func NewUpdateThingConfigRequestWithBody(server string, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingConfigStatusRequest generates requests for GetThingConfigStatus
func NewGetThingConfigStatusRequest(server string, thingUID string, params *GetThingConfigStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/config/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewEnableThingRequestWithTextBody calls the generic EnableThing builder with text/plain body
func NewEnableThingRequestWithTextBody(server string, thingUID string, params *EnableThingParams, body EnableThingTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewEnableThingRequestWithBody(server, thingUID, params, "text/plain", bodyReader)
}

// NewEnableThingRequestWithBody generates requests for EnableThing with any type of body
func NewEnableThingRequestWithBody(server string, thingUID string, params *EnableThingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingFirmwareStatusRequest generates requests for GetThingFirmwareStatus
func NewGetThingFirmwareStatusRequest(server string, thingUID string, params *GetThingFirmwareStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateThingFirmwareRequest generates requests for UpdateThingFirmware
func NewUpdateThingFirmwareRequest(server string, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "firmwareVersion", runtime.ParamLocationPath, firmwareVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmware/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAvailableFirmwaresForThingRequest generates requests for GetAvailableFirmwaresForThing
func NewGetAvailableFirmwaresForThingRequest(server string, thingUID string, params *GetAvailableFirmwaresForThingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/firmwares", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetThingStatusRequest generates requests for GetThingStatus
func NewGetThingStatusRequest(server string, thingUID string, params *GetThingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thingUID", runtime.ParamLocationPath, thingUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/things/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetTransformationsRequest generates requests for GetTransformations
func NewGetTransformationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transformations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransformationServicesRequest generates requests for GetTransformationServices
func NewGetTransformationServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transformations/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTransformationRequest generates requests for DeleteTransformation
func NewDeleteTransformationRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uid", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transformations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransformationRequest generates requests for GetTransformation
func NewGetTransformationRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uid", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transformations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTransformationRequest calls the generic PutTransformation builder with application/json body
func NewPutTransformationRequest(server string, uid string, body PutTransformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTransformationRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutTransformationRequestWithBody generates requests for PutTransformation with any type of body
func NewPutTransformationRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uid", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transformations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRegisteredUIComponentsInNamespaceRequest generates requests for GetRegisteredUIComponentsInNamespace
func NewGetRegisteredUIComponentsInNamespaceRequest(server string, namespace string, params *GetRegisteredUIComponentsInNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUIComponentToNamespaceRequest calls the generic AddUIComponentToNamespace builder with application/json body
func NewAddUIComponentToNamespaceRequest(server string, namespace string, body AddUIComponentToNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUIComponentToNamespaceRequestWithBody(server, namespace, "application/json", bodyReader)
}

// NewAddUIComponentToNamespaceRequestWithBody generates requests for AddUIComponentToNamespace with any type of body
func NewAddUIComponentToNamespaceRequestWithBody(server string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUIComponentFromNamespaceRequest generates requests for RemoveUIComponentFromNamespace
func NewRemoveUIComponentFromNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUIComponentInNamespaceRequest generates requests for GetUIComponentInNamespace
func NewGetUIComponentInNamespaceRequest(server string, namespace string, componentUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUIComponentInNamespaceRequest calls the generic UpdateUIComponentInNamespace builder with application/json body
func NewUpdateUIComponentInNamespaceRequest(server string, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUIComponentInNamespaceRequestWithBody(server, namespace, componentUID, "application/json", bodyReader)
}

// NewUpdateUIComponentInNamespaceRequestWithBody generates requests for UpdateUIComponentInNamespace with any type of body
func NewUpdateUIComponentInNamespaceRequestWithBody(server string, namespace string, componentUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "componentUID", runtime.ParamLocationPath, componentUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/components/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUITilesRequest generates requests for GetUITiles
func NewGetUITilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ui/tiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUUIDRequest generates requests for GetUUID
func NewGetUUIDRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uuid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultVoiceRequest generates requests for GetDefaultVoice
func NewGetDefaultVoiceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/defaultvoice")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartDialogRequest generates requests for StartDialog
func NewStartDialogRequest(server string, params *StartDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/dialog/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceId", runtime.ParamLocationQuery, *params.SourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ksId", runtime.ParamLocationQuery, *params.KsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SttId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sttId", runtime.ParamLocationQuery, *params.SttId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TtsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ttsId", runtime.ParamLocationQuery, *params.TtsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voiceId", runtime.ParamLocationQuery, *params.VoiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HliIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hliIds", runtime.ParamLocationQuery, *params.HliIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SinkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinkId", runtime.ParamLocationQuery, *params.SinkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListeningItem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listeningItem", runtime.ParamLocationQuery, *params.ListeningItem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewStopDialogRequest generates requests for StopDialog
func NewStopDialogRequest(server string, params *StopDialogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/dialog/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceId", runtime.ParamLocationQuery, *params.SourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoiceInterpretersRequest generates requests for GetVoiceInterpreters
func NewGetVoiceInterpretersRequest(server string, params *GetVoiceInterpretersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewInterpretTextByDefaultInterpreterRequestWithTextBody calls the generic InterpretTextByDefaultInterpreter builder with text/plain body
func NewInterpretTextByDefaultInterpreterRequestWithTextBody(server string, params *InterpretTextByDefaultInterpreterParams, body InterpretTextByDefaultInterpreterTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewInterpretTextByDefaultInterpreterRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewInterpretTextByDefaultInterpreterRequestWithBody generates requests for InterpretTextByDefaultInterpreter with any type of body
func NewInterpretTextByDefaultInterpreterRequestWithBody(server string, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewInterpretTextRequestWithTextBody calls the generic InterpretText builder with text/plain body
func NewInterpretTextRequestWithTextBody(server string, ids []string, params *InterpretTextParams, body InterpretTextTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewInterpretTextRequestWithBody(server, ids, params, "text/plain", bodyReader)
}

// NewInterpretTextRequestWithBody generates requests for InterpretText with any type of body
func NewInterpretTextRequestWithBody(server string, ids []string, params *InterpretTextParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ids", runtime.ParamLocationPath, ids)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetVoiceInterpreterByUIDRequest generates requests for GetVoiceInterpreterByUID
func NewGetVoiceInterpreterByUIDRequest(server string, id string, params *GetVoiceInterpreterByUIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/interpreters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewListenAndAnswerRequest generates requests for ListenAndAnswer
func NewListenAndAnswerRequest(server string, params *ListenAndAnswerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/listenandanswer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sourceId", runtime.ParamLocationQuery, *params.SourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SttId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sttId", runtime.ParamLocationQuery, *params.SttId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TtsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ttsId", runtime.ParamLocationQuery, *params.TtsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VoiceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voiceId", runtime.ParamLocationQuery, *params.VoiceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HliIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hliIds", runtime.ParamLocationQuery, *params.HliIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SinkId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinkId", runtime.ParamLocationQuery, *params.SinkId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ListeningItem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "listeningItem", runtime.ParamLocationQuery, *params.ListeningItem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewTextToSpeechRequestWithTextBody calls the generic TextToSpeech builder with text/plain body
func NewTextToSpeechRequestWithTextBody(server string, params *TextToSpeechParams, body TextToSpeechTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewTextToSpeechRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewTextToSpeechRequestWithBody generates requests for TextToSpeech with any type of body
func NewTextToSpeechRequestWithBody(server string, params *TextToSpeechParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/say")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Voiceid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voiceid", runtime.ParamLocationQuery, *params.Voiceid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sinkid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sinkid", runtime.ParamLocationQuery, *params.Sinkid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Volume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume", runtime.ParamLocationQuery, *params.Volume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVoicesRequest generates requests for GetVoices
func NewGetVoicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/voice/voices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetRootWithResponse request
	GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error)

	// GetAvailableActionsForThingWithResponse request
	GetAvailableActionsForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableActionsForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableActionsForThingResponse, error)

	// ExecuteThingActionWithBodyWithResponse request with any body
	ExecuteThingActionWithBodyWithResponse(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteThingActionResponse, error)

	ExecuteThingActionWithResponse(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, body ExecuteThingActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteThingActionResponse, error)

	// GetAddonsWithResponse request
	GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error)

	// GetAddonTypesWithResponse request
	GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error)

	// GetSuggestedAddonsWithResponse request
	GetSuggestedAddonsWithResponse(ctx context.Context, params *GetSuggestedAddonsParams, reqEditors ...RequestEditorFn) (*GetSuggestedAddonsResponse, error)

	// GetAddonServicesWithResponse request
	GetAddonServicesWithResponse(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*GetAddonServicesResponse, error)

	// GetAddonByIdWithResponse request
	GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error)

	// GetAddonConfigurationWithResponse request
	GetAddonConfigurationWithResponse(ctx context.Context, addonId string, params *GetAddonConfigurationParams, reqEditors ...RequestEditorFn) (*GetAddonConfigurationResponse, error)

	// UpdateAddonConfigurationWithBodyWithResponse request with any body
	UpdateAddonConfigurationWithBodyWithResponse(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonConfigurationResponse, error)

	UpdateAddonConfigurationWithResponse(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, body UpdateAddonConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonConfigurationResponse, error)

	// InstallAddonByIdWithResponse request
	InstallAddonByIdWithResponse(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error)

	// UninstallAddonWithResponse request
	UninstallAddonWithResponse(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error)

	// GetAudioDefaultSinkWithResponse request
	GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error)

	// GetAudioDefaultSourceWithResponse request
	GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error)

	// GetAudioSinksWithResponse request
	GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error)

	// GetAudioSourcesWithResponse request
	GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error)

	// GetApiTokensWithResponse request
	GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error)

	// RemoveApiTokenWithResponse request
	RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error)

	// DeleteSessionWithBodyWithResponse request with any body
	DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error)

	DeleteSessionWithFormdataBodyWithResponse(ctx context.Context, body DeleteSessionFormdataRequestBody, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error)

	// GetSessionsForCurrentUserWithResponse request
	GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error)

	// GetOAuthTokenWithBodyWithResponse request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	GetOAuthTokenWithFormdataBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// GetChannelTypesWithResponse request
	GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error)

	// GetChannelTypeByUIDWithResponse request
	GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error)

	// GetLinkableItemTypesByChannelTypeUIDWithResponse request
	GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error)

	// GetConfigDescriptionsWithResponse request
	GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error)

	// GetConfigDescriptionByURIWithResponse request
	GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error)

	// GetBindingsWithDiscoverySupportWithResponse request
	GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error)

	// ScanWithResponse request
	ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error)

	// GetEventsWithResponse request
	GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)

	// InitNewStateTackerWithResponse request
	InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error)

	// UpdateItemListForStateUpdatesWithBodyWithResponse request with any body
	UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error)

	// GetGalleryWidgetListWithResponse request
	GetGalleryWidgetListWithResponse(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetListResponse, error)

	// GetGalleryWidgetsItemWithResponse request
	GetGalleryWidgetsItemWithResponse(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetsItemResponse, error)

	// GetIconSetsWithResponse request
	GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error)

	// GetDiscoveredInboxItemsWithResponse request
	GetDiscoveredInboxItemsWithResponse(ctx context.Context, params *GetDiscoveredInboxItemsParams, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error)

	// RemoveItemFromInboxWithResponse request
	RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error)

	// ApproveInboxItemByIdWithBodyWithResponse request with any body
	ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error)

	ApproveInboxItemByIdWithTextBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, body ApproveInboxItemByIdTextRequestBody, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error)

	// FlagInboxItemAsIgnoredWithResponse request
	FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error)

	// RemoveIgnoreFlagOnInboxItemWithResponse request
	RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error)

	// GetItemsWithResponse request
	GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error)

	// AddOrUpdateItemsInRegistryWithBodyWithResponse request with any body
	AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error)

	// PurgeDatabaseWithResponse request
	PurgeDatabaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeDatabaseResponse, error)

	// RemoveMemberFromGroupItemWithResponse request
	RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error)

	// AddMemberToGroupItemWithResponse request
	AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error)

	// GetSemanticItemWithResponse request
	GetSemanticItemWithResponse(ctx context.Context, itemName string, semanticClass string, params *GetSemanticItemParams, reqEditors ...RequestEditorFn) (*GetSemanticItemResponse, error)

	// RemoveItemFromRegistryWithResponse request
	RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error)

	// GetItemByNameWithResponse request
	GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error)

	// SendItemCommandWithBodyWithResponse request with any body
	SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error)

	SendItemCommandWithTextBodyWithResponse(ctx context.Context, itemname string, body SendItemCommandTextRequestBody, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error)

	// AddOrUpdateItemInRegistryWithBodyWithResponse request with any body
	AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error)

	// GetItemNamespacesWithResponse request
	GetItemNamespacesWithResponse(ctx context.Context, itemname string, params *GetItemNamespacesParams, reqEditors ...RequestEditorFn) (*GetItemNamespacesResponse, error)

	// RemoveMetadataFromItemWithResponse request
	RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error)

	// AddMetadataToItemWithBodyWithResponse request with any body
	AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error)

	// GetItemState1WithResponse request
	GetItemState1WithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemState1Response, error)

	// UpdateItemStateWithBodyWithResponse request with any body
	UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error)

	UpdateItemStateWithTextBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, body UpdateItemStateTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error)

	// RemoveTagFromItemWithResponse request
	RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error)

	// AddTagToItemWithResponse request
	AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error)

	// GetItemLinksWithResponse request
	GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error)

	// GetOrphanLinksWithResponse request
	GetOrphanLinksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrphanLinksResponse, error)

	// PurgeDatabase1WithResponse request
	PurgeDatabase1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeDatabase1Response, error)

	// UnlinkItemFromChannelWithResponse request
	UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error)

	// GetItemLinkWithResponse request
	GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error)

	// LinkItemToChannelWithBodyWithResponse request with any body
	LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error)

	LinkItemToChannelWithResponse(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error)

	// RemoveAllLinksForObjectWithResponse request
	RemoveAllLinksForObjectWithResponse(ctx context.Context, object string, reqEditors ...RequestEditorFn) (*RemoveAllLinksForObjectResponse, error)

	// GetLogger1WithResponse request
	GetLogger1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogger1Response, error)

	// RemoveLoggerWithResponse request
	RemoveLoggerWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*RemoveLoggerResponse, error)

	// GetLoggerWithResponse request
	GetLoggerWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*GetLoggerResponse, error)

	// PutLoggerWithBodyWithResponse request with any body
	PutLoggerWithBodyWithResponse(ctx context.Context, loggerName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLoggerResponse, error)

	PutLoggerWithResponse(ctx context.Context, loggerName string, body PutLoggerJSONRequestBody, reqEditors ...RequestEditorFn) (*PutLoggerResponse, error)

	// GetModuleTypesWithResponse request
	GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error)

	// GetModuleTypeByIdWithResponse request
	GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error)

	// GetPersistenceServicesWithResponse request
	GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error)

	// GetItemsForPersistenceServiceWithResponse request
	GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error)

	// DeleteItemFromPersistenceServiceWithResponse request
	DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error)

	// GetItemDataFromPersistenceServiceWithResponse request
	GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error)

	// StoreItemDataInPersistenceServiceWithResponse request
	StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error)

	// DeletePersistenceServiceConfigurationWithResponse request
	DeletePersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeletePersistenceServiceConfigurationResponse, error)

	// GetPersistenceServiceConfigurationWithResponse request
	GetPersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetPersistenceServiceConfigurationResponse, error)

	// PutPersistenceServiceConfigurationWithBodyWithResponse request with any body
	PutPersistenceServiceConfigurationWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPersistenceServiceConfigurationResponse, error)

	PutPersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, body PutPersistenceServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPersistenceServiceConfigurationResponse, error)

	// GetProfileTypesWithResponse request
	GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error)

	// GetRulesWithResponse request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// CreateRuleWithBodyWithResponse request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// GetScheduleRuleSimulationsWithResponse request
	GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleByIdWithResponse request
	GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error)

	// UpdateRuleWithBodyWithResponse request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// GetRuleActionsWithResponse request
	GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error)

	// GetRuleConditionsWithResponse request
	GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error)

	// GetRuleConfigurationWithResponse request
	GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error)

	// UpdateRuleConfigurationWithBodyWithResponse request with any body
	UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error)

	// EnableRuleWithBodyWithResponse request with any body
	EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error)

	EnableRuleWithTextBodyWithResponse(ctx context.Context, ruleUID string, body EnableRuleTextRequestBody, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error)

	// RunRuleNow1WithBodyWithResponse request with any body
	RunRuleNow1WithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunRuleNow1Response, error)

	RunRuleNow1WithResponse(ctx context.Context, ruleUID string, body RunRuleNow1JSONRequestBody, reqEditors ...RequestEditorFn) (*RunRuleNow1Response, error)

	// GetRuleTriggersWithResponse request
	GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error)

	// GetRuleModuleByIdWithResponse request
	GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error)

	// GetRuleModuleConfigWithResponse request
	GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error)

	// GetRuleModuleConfigParameterWithResponse request
	GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error)

	// SetRuleModuleConfigParameterWithBodyWithResponse request with any body
	SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error)

	SetRuleModuleConfigParameterWithTextBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, body SetRuleModuleConfigParameterTextRequestBody, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error)

	// GetServicesWithResponse request
	GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// GetServicesByIdWithResponse request
	GetServicesByIdWithResponse(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error)

	// DeleteServiceConfigWithResponse request
	DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error)

	// GetServiceConfigWithResponse request
	GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error)

	// UpdateServiceConfigWithBodyWithResponse request with any body
	UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error)

	// GetServiceContextWithResponse request
	GetServiceContextWithResponse(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error)

	// GetSitemapsWithResponse request
	GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error)

	// CreateSitemapEventSubscriptionWithResponse request
	CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error)

	// GetSitemapEvents1WithResponse request
	GetSitemapEvents1WithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEvents1Params, reqEditors ...RequestEditorFn) (*GetSitemapEvents1Response, error)

	// GetSitemapEventsWithResponse request
	GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error)

	// GetSitemapByNameWithResponse request
	GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error)

	// PollDataForSitemapWithResponse request
	PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error)

	// PollDataForPageWithResponse request
	PollDataForPageWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForPageParams, reqEditors ...RequestEditorFn) (*PollDataForPageResponse, error)

	// GetSystemInformationWithResponse request
	GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error)

	// GetUoMInformationWithResponse request
	GetUoMInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUoMInformationResponse, error)

	// GetSemanticTagsWithResponse request
	GetSemanticTagsWithResponse(ctx context.Context, params *GetSemanticTagsParams, reqEditors ...RequestEditorFn) (*GetSemanticTagsResponse, error)

	// CreateSemanticTagWithBodyWithResponse request with any body
	CreateSemanticTagWithBodyWithResponse(ctx context.Context, params *CreateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSemanticTagResponse, error)

	CreateSemanticTagWithResponse(ctx context.Context, params *CreateSemanticTagParams, body CreateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSemanticTagResponse, error)

	// RemoveSemanticTagWithResponse request
	RemoveSemanticTagWithResponse(ctx context.Context, tagId string, params *RemoveSemanticTagParams, reqEditors ...RequestEditorFn) (*RemoveSemanticTagResponse, error)

	// GetSemanticTagAndSubTagsWithResponse request
	GetSemanticTagAndSubTagsWithResponse(ctx context.Context, tagId string, params *GetSemanticTagAndSubTagsParams, reqEditors ...RequestEditorFn) (*GetSemanticTagAndSubTagsResponse, error)

	// UpdateSemanticTagWithBodyWithResponse request with any body
	UpdateSemanticTagWithBodyWithResponse(ctx context.Context, tagId string, params *UpdateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSemanticTagResponse, error)

	UpdateSemanticTagWithResponse(ctx context.Context, tagId string, params *UpdateSemanticTagParams, body UpdateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSemanticTagResponse, error)

	// GetTemplatesWithResponse request
	GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error)

	// GetTemplateByIdWithResponse request
	GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error)

	// GetThingTypesWithResponse request
	GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error)

	// GetThingTypeByIdWithResponse request
	GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error)

	// GetThingsWithResponse request
	GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error)

	// CreateThingInRegistryWithBodyWithResponse request with any body
	CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error)

	// RemoveThingByIdWithResponse request
	RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error)

	// GetThingByIdWithResponse request
	GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error)

	// UpdateThingWithBodyWithResponse request with any body
	UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error)

	// UpdateThingConfigWithBodyWithResponse request with any body
	UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error)

	// GetThingConfigStatusWithResponse request
	GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error)

	// EnableThingWithBodyWithResponse request with any body
	EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error)

	EnableThingWithTextBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, body EnableThingTextRequestBody, reqEditors ...RequestEditorFn) (*EnableThingResponse, error)

	// GetThingFirmwareStatusWithResponse request
	GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error)

	// UpdateThingFirmwareWithResponse request
	UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error)

	// GetAvailableFirmwaresForThingWithResponse request
	GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error)

	// GetThingStatusWithResponse request
	GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error)

	// GetTransformationsWithResponse request
	GetTransformationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTransformationsResponse, error)

	// GetTransformationServicesWithResponse request
	GetTransformationServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTransformationServicesResponse, error)

	// DeleteTransformationWithResponse request
	DeleteTransformationWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteTransformationResponse, error)

	// GetTransformationWithResponse request
	GetTransformationWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetTransformationResponse, error)

	// PutTransformationWithBodyWithResponse request with any body
	PutTransformationWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTransformationResponse, error)

	PutTransformationWithResponse(ctx context.Context, uid string, body PutTransformationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTransformationResponse, error)

	// GetRegisteredUIComponentsInNamespaceWithResponse request
	GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error)

	// AddUIComponentToNamespaceWithBodyWithResponse request with any body
	AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error)

	AddUIComponentToNamespaceWithResponse(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error)

	// RemoveUIComponentFromNamespaceWithResponse request
	RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error)

	// GetUIComponentInNamespaceWithResponse request
	GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error)

	// UpdateUIComponentInNamespaceWithBodyWithResponse request with any body
	UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error)

	UpdateUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error)

	// GetUITilesWithResponse request
	GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error)

	// GetUUIDWithResponse request
	GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error)

	// GetDefaultVoiceWithResponse request
	GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error)

	// StartDialogWithResponse request
	StartDialogWithResponse(ctx context.Context, params *StartDialogParams, reqEditors ...RequestEditorFn) (*StartDialogResponse, error)

	// StopDialogWithResponse request
	StopDialogWithResponse(ctx context.Context, params *StopDialogParams, reqEditors ...RequestEditorFn) (*StopDialogResponse, error)

	// GetVoiceInterpretersWithResponse request
	GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error)

	// InterpretTextByDefaultInterpreterWithBodyWithResponse request with any body
	InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error)

	InterpretTextByDefaultInterpreterWithTextBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, body InterpretTextByDefaultInterpreterTextRequestBody, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error)

	// InterpretTextWithBodyWithResponse request with any body
	InterpretTextWithBodyWithResponse(ctx context.Context, ids []string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error)

	InterpretTextWithTextBodyWithResponse(ctx context.Context, ids []string, params *InterpretTextParams, body InterpretTextTextRequestBody, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error)

	// GetVoiceInterpreterByUIDWithResponse request
	GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error)

	// ListenAndAnswerWithResponse request
	ListenAndAnswerWithResponse(ctx context.Context, params *ListenAndAnswerParams, reqEditors ...RequestEditorFn) (*ListenAndAnswerResponse, error)

	// TextToSpeechWithBodyWithResponse request with any body
	TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error)

	TextToSpeechWithTextBodyWithResponse(ctx context.Context, params *TextToSpeechParams, body TextToSpeechTextRequestBody, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error)

	// GetVoicesWithResponse request
	GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error)
}

type GetRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootBean
}

// Status returns HTTPResponse.Status
func (r GetRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableActionsForThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ThingActionDTO
}

// Status returns HTTPResponse.Status
func (r GetAvailableActionsForThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableActionsForThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteThingActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r ExecuteThingActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteThingActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddonType
}

// Status returns HTTPResponse.Status
func (r GetAddonTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSuggestedAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Addon
}

// Status returns HTTPResponse.Status
func (r GetSuggestedAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSuggestedAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AddonType
}

// Status returns HTTPResponse.Status
func (r GetAddonServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Addon
}

// Status returns HTTPResponse.Status
func (r GetAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetAddonConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAddonConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateAddonConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAddonConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallAddonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallAddonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallAddonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UninstallAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UninstallAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UninstallAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioDefaultSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioDefaultSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioDefaultSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSinkDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAudioSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AudioSourceDTO
}

// Status returns HTTPResponse.Status
func (r GetAudioSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAudioSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserApiTokenDTO
}

// Status returns HTTPResponse.Status
func (r GetApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveApiTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveApiTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveApiTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionsForCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserSessionDTO
}

// Status returns HTTPResponse.Status
func (r GetSessionsForCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionsForCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponseDTO
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTypeByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetChannelTypeByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTypeByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkableItemTypesByChannelTypeUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetLinkableItemTypesByChannelTypeUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkableItemTypesByChannelTypeUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigDescriptionByURIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigDescriptionDTO
}

// Status returns HTTPResponse.Status
func (r GetConfigDescriptionByURIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigDescriptionByURIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindingsWithDiscoverySupportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetBindingsWithDiscoverySupportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindingsWithDiscoverySupportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitNewStateTackerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InitNewStateTackerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitNewStateTackerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemListForStateUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemListForStateUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemListForStateUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGalleryWidgetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GalleryWidgetsListItem
}

// Status returns HTTPResponse.Status
func (r GetGalleryWidgetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGalleryWidgetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGalleryWidgetsItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GalleryItem
}

// Status returns HTTPResponse.Status
func (r GetGalleryWidgetsItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGalleryWidgetsItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIconSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IconSet
}

// Status returns HTTPResponse.Status
func (r GetIconSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIconSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscoveredInboxItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DiscoveryResultDTO
}

// Status returns HTTPResponse.Status
func (r GetDiscoveredInboxItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscoveredInboxItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromInboxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromInboxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromInboxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveInboxItemByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ApproveInboxItemByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveInboxItemByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FlagInboxItemAsIgnoredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FlagInboxItemAsIgnoredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FlagInboxItemAsIgnoredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveIgnoreFlagOnInboxItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveIgnoreFlagOnInboxItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveIgnoreFlagOnInboxItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemsInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemsInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemsInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PurgeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMemberFromGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMemberFromGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMemberFromGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMemberToGroupItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMemberToGroupItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMemberToGroupItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSemanticItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSemanticItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSemanticItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveItemFromRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveItemFromRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveItemFromRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedItemDTO
}

// Status returns HTTPResponse.Status
func (r GetItemByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendItemCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendItemCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendItemCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrUpdateItemInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOrUpdateItemInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrUpdateItemInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetItemNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMetadataFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveMetadataFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMetadataFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMetadataToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddMetadataToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMetadataToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemState1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetItemState1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemState1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateItemStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateItemStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateItemStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTagFromItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveTagFromItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTagFromItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTagToItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddTagToItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTagToItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedItemChannelLinkDTO
}

// Status returns HTTPResponse.Status
func (r GetItemLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrphanLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOrphanLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrphanLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeDatabase1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PurgeDatabase1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeDatabase1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnlinkItemFromChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnlinkItemFromChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnlinkItemFromChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedItemChannelLinkDTO
}

// Status returns HTTPResponse.Status
func (r GetItemLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkItemToChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LinkItemToChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkItemToChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveAllLinksForObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveAllLinksForObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveAllLinksForObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogger1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoggerBean
}

// Status returns HTTPResponse.Status
func (r GetLogger1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogger1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveLoggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveLoggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveLoggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoggerInfo
}

// Status returns HTTPResponse.Status
func (r GetLoggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutLoggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutLoggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutLoggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModuleTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetModuleTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModuleTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetPersistenceServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsForPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PersistenceItemInfo
}

// Status returns HTTPResponse.Status
func (r GetItemsForPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsForPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteItemFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r DeleteItemFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemDataFromPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ItemHistoryDTO
}

// Status returns HTTPResponse.Status
func (r GetItemDataFromPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemDataFromPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreItemDataInPersistenceServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StoreItemDataInPersistenceServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreItemDataInPersistenceServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePersistenceServiceConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePersistenceServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePersistenceServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersistenceServiceConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistenceServiceConfigurationDTO
}

// Status returns HTTPResponse.Status
func (r GetPersistenceServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersistenceServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPersistenceServiceConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistenceServiceConfigurationDTO
}

// Status returns HTTPResponse.Status
func (r PutPersistenceServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPersistenceServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProfileTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetProfileTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleRuleSimulationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RuleExecution
}

// Status returns HTTPResponse.Status
func (r GetScheduleRuleSimulationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleRuleSimulationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedRuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConditionDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunRuleNow1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunRuleNow1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunRuleNow1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleTriggersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TriggerDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleTriggersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleTriggersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModuleDTO
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRuleModuleConfigParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetRuleModuleConfigParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRuleModuleConfigParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServicesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigurableServiceDTO
}

// Status returns HTTPResponse.Status
func (r GetServiceContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSitemapEventSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSitemapEventSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSitemapEventSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapEvents1Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSitemapEvents1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapEvents1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSitemapEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitemapByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitemapDTO
}

// Status returns HTTPResponse.Status
func (r GetSitemapByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitemapByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollDataForSitemapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SitemapDTO
}

// Status returns HTTPResponse.Status
func (r PollDataForSitemapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollDataForSitemapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PollDataForPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageDTO
}

// Status returns HTTPResponse.Status
func (r PollDataForPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PollDataForPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemInfoBean
}

// Status returns HTTPResponse.Status
func (r GetSystemInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUoMInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UoMInfoBean
}

// Status returns HTTPResponse.Status
func (r GetUoMInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUoMInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSemanticTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedSemanticTagDTO
}

// Status returns HTTPResponse.Status
func (r GetSemanticTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSemanticTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSemanticTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSemanticTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSemanticTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSemanticTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveSemanticTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSemanticTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSemanticTagAndSubTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedSemanticTagDTO
}

// Status returns HTTPResponse.Status
func (r GetSemanticTagAndSubTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSemanticTagAndSubTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSemanticTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSemanticTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSemanticTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Template
}

// Status returns HTTPResponse.Status
func (r GetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTemplateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Template
}

// Status returns HTTPResponse.Status
func (r GetTemplateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTemplateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]StrippedThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingTypeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingTypeDTO
}

// Status returns HTTPResponse.Status
func (r GetThingTypeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingTypeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateThingInRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateThingInRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateThingInRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedThingDTO
}

// Status returns HTTPResponse.Status
func (r GetThingByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingConfigStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConfigStatusMessage
}

// Status returns HTTPResponse.Status
func (r GetThingConfigStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingConfigStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingFirmwareStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetThingFirmwareStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingFirmwareStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateThingFirmwareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateThingFirmwareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateThingFirmwareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableFirmwaresForThingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FirmwareDTO
}

// Status returns HTTPResponse.Status
func (r GetAvailableFirmwaresForThingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableFirmwaresForThingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThingStatusInfo
}

// Status returns HTTPResponse.Status
func (r GetThingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransformationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TransformationDTO
}

// Status returns HTTPResponse.Status
func (r GetTransformationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransformationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransformationServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetTransformationServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransformationServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTransformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transformation
}

// Status returns HTTPResponse.Status
func (r GetTransformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTransformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutTransformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTransformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegisteredUIComponentsInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetRegisteredUIComponentsInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegisteredUIComponentsInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUIComponentToNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r AddUIComponentToNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUIComponentToNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUIComponentFromNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUIComponentFromNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUIComponentFromNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r GetUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUIComponentInNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RootUIComponent
}

// Status returns HTTPResponse.Status
func (r UpdateUIComponentInNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUIComponentInNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUITilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TileDTO
}

// Status returns HTTPResponse.Status
func (r GetUITilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUITilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultVoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetDefaultVoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultVoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StartDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopDialogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StopDialogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopDialogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpretersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpretersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpretersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextByDefaultInterpreterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextByDefaultInterpreterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextByDefaultInterpreterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InterpretTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InterpretTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InterpretTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoiceInterpreterByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HumanLanguageInterpreterDTO
}

// Status returns HTTPResponse.Status
func (r GetVoiceInterpreterByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoiceInterpreterByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListenAndAnswerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListenAndAnswerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenAndAnswerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TextToSpeechResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TextToSpeechResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TextToSpeechResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VoiceDTO
}

// Status returns HTTPResponse.Status
func (r GetVoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetRootWithResponse request returning *GetRootResponse
func (c *ClientWithResponses) GetRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRootResponse, error) {
	rsp, err := c.GetRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRootResponse(rsp)
}

// GetAvailableActionsForThingWithResponse request returning *GetAvailableActionsForThingResponse
func (c *ClientWithResponses) GetAvailableActionsForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableActionsForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableActionsForThingResponse, error) {
	rsp, err := c.GetAvailableActionsForThing(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableActionsForThingResponse(rsp)
}

// ExecuteThingActionWithBodyWithResponse request with arbitrary body returning *ExecuteThingActionResponse
func (c *ClientWithResponses) ExecuteThingActionWithBodyWithResponse(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteThingActionResponse, error) {
	rsp, err := c.ExecuteThingActionWithBody(ctx, thingUID, actionUid, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteThingActionResponse(rsp)
}

func (c *ClientWithResponses) ExecuteThingActionWithResponse(ctx context.Context, thingUID string, actionUid string, params *ExecuteThingActionParams, body ExecuteThingActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteThingActionResponse, error) {
	rsp, err := c.ExecuteThingAction(ctx, thingUID, actionUid, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteThingActionResponse(rsp)
}

// GetAddonsWithResponse request returning *GetAddonsResponse
func (c *ClientWithResponses) GetAddonsWithResponse(ctx context.Context, params *GetAddonsParams, reqEditors ...RequestEditorFn) (*GetAddonsResponse, error) {
	rsp, err := c.GetAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonsResponse(rsp)
}

// GetAddonTypesWithResponse request returning *GetAddonTypesResponse
func (c *ClientWithResponses) GetAddonTypesWithResponse(ctx context.Context, params *GetAddonTypesParams, reqEditors ...RequestEditorFn) (*GetAddonTypesResponse, error) {
	rsp, err := c.GetAddonTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonTypesResponse(rsp)
}

// GetSuggestedAddonsWithResponse request returning *GetSuggestedAddonsResponse
func (c *ClientWithResponses) GetSuggestedAddonsWithResponse(ctx context.Context, params *GetSuggestedAddonsParams, reqEditors ...RequestEditorFn) (*GetSuggestedAddonsResponse, error) {
	rsp, err := c.GetSuggestedAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSuggestedAddonsResponse(rsp)
}

// GetAddonServicesWithResponse request returning *GetAddonServicesResponse
func (c *ClientWithResponses) GetAddonServicesWithResponse(ctx context.Context, params *GetAddonServicesParams, reqEditors ...RequestEditorFn) (*GetAddonServicesResponse, error) {
	rsp, err := c.GetAddonServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonServicesResponse(rsp)
}

// GetAddonByIdWithResponse request returning *GetAddonByIdResponse
func (c *ClientWithResponses) GetAddonByIdWithResponse(ctx context.Context, addonId string, params *GetAddonByIdParams, reqEditors ...RequestEditorFn) (*GetAddonByIdResponse, error) {
	rsp, err := c.GetAddonById(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonByIdResponse(rsp)
}

// GetAddonConfigurationWithResponse request returning *GetAddonConfigurationResponse
func (c *ClientWithResponses) GetAddonConfigurationWithResponse(ctx context.Context, addonId string, params *GetAddonConfigurationParams, reqEditors ...RequestEditorFn) (*GetAddonConfigurationResponse, error) {
	rsp, err := c.GetAddonConfiguration(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonConfigurationResponse(rsp)
}

// UpdateAddonConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateAddonConfigurationResponse
func (c *ClientWithResponses) UpdateAddonConfigurationWithBodyWithResponse(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonConfigurationResponse, error) {
	rsp, err := c.UpdateAddonConfigurationWithBody(ctx, addonId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateAddonConfigurationWithResponse(ctx context.Context, addonId string, params *UpdateAddonConfigurationParams, body UpdateAddonConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonConfigurationResponse, error) {
	rsp, err := c.UpdateAddonConfiguration(ctx, addonId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonConfigurationResponse(rsp)
}

// InstallAddonByIdWithResponse request returning *InstallAddonByIdResponse
func (c *ClientWithResponses) InstallAddonByIdWithResponse(ctx context.Context, addonId string, params *InstallAddonByIdParams, reqEditors ...RequestEditorFn) (*InstallAddonByIdResponse, error) {
	rsp, err := c.InstallAddonById(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallAddonByIdResponse(rsp)
}

// UninstallAddonWithResponse request returning *UninstallAddonResponse
func (c *ClientWithResponses) UninstallAddonWithResponse(ctx context.Context, addonId string, params *UninstallAddonParams, reqEditors ...RequestEditorFn) (*UninstallAddonResponse, error) {
	rsp, err := c.UninstallAddon(ctx, addonId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUninstallAddonResponse(rsp)
}

// GetAudioDefaultSinkWithResponse request returning *GetAudioDefaultSinkResponse
func (c *ClientWithResponses) GetAudioDefaultSinkWithResponse(ctx context.Context, params *GetAudioDefaultSinkParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSinkResponse, error) {
	rsp, err := c.GetAudioDefaultSink(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSinkResponse(rsp)
}

// GetAudioDefaultSourceWithResponse request returning *GetAudioDefaultSourceResponse
func (c *ClientWithResponses) GetAudioDefaultSourceWithResponse(ctx context.Context, params *GetAudioDefaultSourceParams, reqEditors ...RequestEditorFn) (*GetAudioDefaultSourceResponse, error) {
	rsp, err := c.GetAudioDefaultSource(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioDefaultSourceResponse(rsp)
}

// GetAudioSinksWithResponse request returning *GetAudioSinksResponse
func (c *ClientWithResponses) GetAudioSinksWithResponse(ctx context.Context, params *GetAudioSinksParams, reqEditors ...RequestEditorFn) (*GetAudioSinksResponse, error) {
	rsp, err := c.GetAudioSinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSinksResponse(rsp)
}

// GetAudioSourcesWithResponse request returning *GetAudioSourcesResponse
func (c *ClientWithResponses) GetAudioSourcesWithResponse(ctx context.Context, params *GetAudioSourcesParams, reqEditors ...RequestEditorFn) (*GetAudioSourcesResponse, error) {
	rsp, err := c.GetAudioSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAudioSourcesResponse(rsp)
}

// GetApiTokensWithResponse request returning *GetApiTokensResponse
func (c *ClientWithResponses) GetApiTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetApiTokensResponse, error) {
	rsp, err := c.GetApiTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiTokensResponse(rsp)
}

// RemoveApiTokenWithResponse request returning *RemoveApiTokenResponse
func (c *ClientWithResponses) RemoveApiTokenWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RemoveApiTokenResponse, error) {
	rsp, err := c.RemoveApiToken(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveApiTokenResponse(rsp)
}

// DeleteSessionWithBodyWithResponse request with arbitrary body returning *DeleteSessionResponse
func (c *ClientWithResponses) DeleteSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error) {
	rsp, err := c.DeleteSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionResponse(rsp)
}

func (c *ClientWithResponses) DeleteSessionWithFormdataBodyWithResponse(ctx context.Context, body DeleteSessionFormdataRequestBody, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error) {
	rsp, err := c.DeleteSessionWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionResponse(rsp)
}

// GetSessionsForCurrentUserWithResponse request returning *GetSessionsForCurrentUserResponse
func (c *ClientWithResponses) GetSessionsForCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSessionsForCurrentUserResponse, error) {
	rsp, err := c.GetSessionsForCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionsForCurrentUserResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) GetOAuthTokenWithFormdataBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// GetChannelTypesWithResponse request returning *GetChannelTypesResponse
func (c *ClientWithResponses) GetChannelTypesWithResponse(ctx context.Context, params *GetChannelTypesParams, reqEditors ...RequestEditorFn) (*GetChannelTypesResponse, error) {
	rsp, err := c.GetChannelTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypesResponse(rsp)
}

// GetChannelTypeByUIDWithResponse request returning *GetChannelTypeByUIDResponse
func (c *ClientWithResponses) GetChannelTypeByUIDWithResponse(ctx context.Context, channelTypeUID string, params *GetChannelTypeByUIDParams, reqEditors ...RequestEditorFn) (*GetChannelTypeByUIDResponse, error) {
	rsp, err := c.GetChannelTypeByUID(ctx, channelTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelTypeByUIDResponse(rsp)
}

// GetLinkableItemTypesByChannelTypeUIDWithResponse request returning *GetLinkableItemTypesByChannelTypeUIDResponse
func (c *ClientWithResponses) GetLinkableItemTypesByChannelTypeUIDWithResponse(ctx context.Context, channelTypeUID string, reqEditors ...RequestEditorFn) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	rsp, err := c.GetLinkableItemTypesByChannelTypeUID(ctx, channelTypeUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp)
}

// GetConfigDescriptionsWithResponse request returning *GetConfigDescriptionsResponse
func (c *ClientWithResponses) GetConfigDescriptionsWithResponse(ctx context.Context, params *GetConfigDescriptionsParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionsResponse, error) {
	rsp, err := c.GetConfigDescriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionsResponse(rsp)
}

// GetConfigDescriptionByURIWithResponse request returning *GetConfigDescriptionByURIResponse
func (c *ClientWithResponses) GetConfigDescriptionByURIWithResponse(ctx context.Context, uri string, params *GetConfigDescriptionByURIParams, reqEditors ...RequestEditorFn) (*GetConfigDescriptionByURIResponse, error) {
	rsp, err := c.GetConfigDescriptionByURI(ctx, uri, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigDescriptionByURIResponse(rsp)
}

// GetBindingsWithDiscoverySupportWithResponse request returning *GetBindingsWithDiscoverySupportResponse
func (c *ClientWithResponses) GetBindingsWithDiscoverySupportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBindingsWithDiscoverySupportResponse, error) {
	rsp, err := c.GetBindingsWithDiscoverySupport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindingsWithDiscoverySupportResponse(rsp)
}

// ScanWithResponse request returning *ScanResponse
func (c *ClientWithResponses) ScanWithResponse(ctx context.Context, bindingId string, reqEditors ...RequestEditorFn) (*ScanResponse, error) {
	rsp, err := c.Scan(ctx, bindingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScanResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// InitNewStateTackerWithResponse request returning *InitNewStateTackerResponse
func (c *ClientWithResponses) InitNewStateTackerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitNewStateTackerResponse, error) {
	rsp, err := c.InitNewStateTacker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitNewStateTackerResponse(rsp)
}

// UpdateItemListForStateUpdatesWithBodyWithResponse request with arbitrary body returning *UpdateItemListForStateUpdatesResponse
func (c *ClientWithResponses) UpdateItemListForStateUpdatesWithBodyWithResponse(ctx context.Context, connectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemListForStateUpdatesResponse, error) {
	rsp, err := c.UpdateItemListForStateUpdatesWithBody(ctx, connectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemListForStateUpdatesResponse(rsp)
}

// GetGalleryWidgetListWithResponse request returning *GetGalleryWidgetListResponse
func (c *ClientWithResponses) GetGalleryWidgetListWithResponse(ctx context.Context, galleryName string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetListResponse, error) {
	rsp, err := c.GetGalleryWidgetList(ctx, galleryName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGalleryWidgetListResponse(rsp)
}

// GetGalleryWidgetsItemWithResponse request returning *GetGalleryWidgetsItemResponse
func (c *ClientWithResponses) GetGalleryWidgetsItemWithResponse(ctx context.Context, galleryName string, id string, reqEditors ...RequestEditorFn) (*GetGalleryWidgetsItemResponse, error) {
	rsp, err := c.GetGalleryWidgetsItem(ctx, galleryName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGalleryWidgetsItemResponse(rsp)
}

// GetIconSetsWithResponse request returning *GetIconSetsResponse
func (c *ClientWithResponses) GetIconSetsWithResponse(ctx context.Context, params *GetIconSetsParams, reqEditors ...RequestEditorFn) (*GetIconSetsResponse, error) {
	rsp, err := c.GetIconSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIconSetsResponse(rsp)
}

// GetDiscoveredInboxItemsWithResponse request returning *GetDiscoveredInboxItemsResponse
func (c *ClientWithResponses) GetDiscoveredInboxItemsWithResponse(ctx context.Context, params *GetDiscoveredInboxItemsParams, reqEditors ...RequestEditorFn) (*GetDiscoveredInboxItemsResponse, error) {
	rsp, err := c.GetDiscoveredInboxItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscoveredInboxItemsResponse(rsp)
}

// RemoveItemFromInboxWithResponse request returning *RemoveItemFromInboxResponse
func (c *ClientWithResponses) RemoveItemFromInboxWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveItemFromInboxResponse, error) {
	rsp, err := c.RemoveItemFromInbox(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromInboxResponse(rsp)
}

// ApproveInboxItemByIdWithBodyWithResponse request with arbitrary body returning *ApproveInboxItemByIdResponse
func (c *ClientWithResponses) ApproveInboxItemByIdWithBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error) {
	rsp, err := c.ApproveInboxItemByIdWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveInboxItemByIdResponse(rsp)
}

func (c *ClientWithResponses) ApproveInboxItemByIdWithTextBodyWithResponse(ctx context.Context, thingUID string, params *ApproveInboxItemByIdParams, body ApproveInboxItemByIdTextRequestBody, reqEditors ...RequestEditorFn) (*ApproveInboxItemByIdResponse, error) {
	rsp, err := c.ApproveInboxItemByIdWithTextBody(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveInboxItemByIdResponse(rsp)
}

// FlagInboxItemAsIgnoredWithResponse request returning *FlagInboxItemAsIgnoredResponse
func (c *ClientWithResponses) FlagInboxItemAsIgnoredWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*FlagInboxItemAsIgnoredResponse, error) {
	rsp, err := c.FlagInboxItemAsIgnored(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFlagInboxItemAsIgnoredResponse(rsp)
}

// RemoveIgnoreFlagOnInboxItemWithResponse request returning *RemoveIgnoreFlagOnInboxItemResponse
func (c *ClientWithResponses) RemoveIgnoreFlagOnInboxItemWithResponse(ctx context.Context, thingUID string, reqEditors ...RequestEditorFn) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	rsp, err := c.RemoveIgnoreFlagOnInboxItem(ctx, thingUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveIgnoreFlagOnInboxItemResponse(rsp)
}

// GetItemsWithResponse request returning *GetItemsResponse
func (c *ClientWithResponses) GetItemsWithResponse(ctx context.Context, params *GetItemsParams, reqEditors ...RequestEditorFn) (*GetItemsResponse, error) {
	rsp, err := c.GetItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsResponse(rsp)
}

// AddOrUpdateItemsInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemsInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemsInRegistryWithResponse(ctx context.Context, body AddOrUpdateItemsInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemsInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemsInRegistry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemsInRegistryResponse(rsp)
}

// PurgeDatabaseWithResponse request returning *PurgeDatabaseResponse
func (c *ClientWithResponses) PurgeDatabaseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeDatabaseResponse, error) {
	rsp, err := c.PurgeDatabase(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeDatabaseResponse(rsp)
}

// RemoveMemberFromGroupItemWithResponse request returning *RemoveMemberFromGroupItemResponse
func (c *ClientWithResponses) RemoveMemberFromGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*RemoveMemberFromGroupItemResponse, error) {
	rsp, err := c.RemoveMemberFromGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMemberFromGroupItemResponse(rsp)
}

// AddMemberToGroupItemWithResponse request returning *AddMemberToGroupItemResponse
func (c *ClientWithResponses) AddMemberToGroupItemWithResponse(ctx context.Context, itemName string, memberItemName string, reqEditors ...RequestEditorFn) (*AddMemberToGroupItemResponse, error) {
	rsp, err := c.AddMemberToGroupItem(ctx, itemName, memberItemName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMemberToGroupItemResponse(rsp)
}

// GetSemanticItemWithResponse request returning *GetSemanticItemResponse
func (c *ClientWithResponses) GetSemanticItemWithResponse(ctx context.Context, itemName string, semanticClass string, params *GetSemanticItemParams, reqEditors ...RequestEditorFn) (*GetSemanticItemResponse, error) {
	rsp, err := c.GetSemanticItem(ctx, itemName, semanticClass, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSemanticItemResponse(rsp)
}

// RemoveItemFromRegistryWithResponse request returning *RemoveItemFromRegistryResponse
func (c *ClientWithResponses) RemoveItemFromRegistryWithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*RemoveItemFromRegistryResponse, error) {
	rsp, err := c.RemoveItemFromRegistry(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveItemFromRegistryResponse(rsp)
}

// GetItemByNameWithResponse request returning *GetItemByNameResponse
func (c *ClientWithResponses) GetItemByNameWithResponse(ctx context.Context, itemname string, params *GetItemByNameParams, reqEditors ...RequestEditorFn) (*GetItemByNameResponse, error) {
	rsp, err := c.GetItemByName(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemByNameResponse(rsp)
}

// SendItemCommandWithBodyWithResponse request with arbitrary body returning *SendItemCommandResponse
func (c *ClientWithResponses) SendItemCommandWithBodyWithResponse(ctx context.Context, itemname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error) {
	rsp, err := c.SendItemCommandWithBody(ctx, itemname, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendItemCommandResponse(rsp)
}

func (c *ClientWithResponses) SendItemCommandWithTextBodyWithResponse(ctx context.Context, itemname string, body SendItemCommandTextRequestBody, reqEditors ...RequestEditorFn) (*SendItemCommandResponse, error) {
	rsp, err := c.SendItemCommandWithTextBody(ctx, itemname, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendItemCommandResponse(rsp)
}

// AddOrUpdateItemInRegistryWithBodyWithResponse request with arbitrary body returning *AddOrUpdateItemInRegistryResponse
func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithBodyWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistryWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

func (c *ClientWithResponses) AddOrUpdateItemInRegistryWithResponse(ctx context.Context, itemname string, params *AddOrUpdateItemInRegistryParams, body AddOrUpdateItemInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrUpdateItemInRegistryResponse, error) {
	rsp, err := c.AddOrUpdateItemInRegistry(ctx, itemname, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrUpdateItemInRegistryResponse(rsp)
}

// GetItemNamespacesWithResponse request returning *GetItemNamespacesResponse
func (c *ClientWithResponses) GetItemNamespacesWithResponse(ctx context.Context, itemname string, params *GetItemNamespacesParams, reqEditors ...RequestEditorFn) (*GetItemNamespacesResponse, error) {
	rsp, err := c.GetItemNamespaces(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemNamespacesResponse(rsp)
}

// RemoveMetadataFromItemWithResponse request returning *RemoveMetadataFromItemResponse
func (c *ClientWithResponses) RemoveMetadataFromItemWithResponse(ctx context.Context, itemname string, namespace string, reqEditors ...RequestEditorFn) (*RemoveMetadataFromItemResponse, error) {
	rsp, err := c.RemoveMetadataFromItem(ctx, itemname, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMetadataFromItemResponse(rsp)
}

// AddMetadataToItemWithBodyWithResponse request with arbitrary body returning *AddMetadataToItemResponse
func (c *ClientWithResponses) AddMetadataToItemWithBodyWithResponse(ctx context.Context, itemname string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItemWithBody(ctx, itemname, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

func (c *ClientWithResponses) AddMetadataToItemWithResponse(ctx context.Context, itemname string, namespace string, body AddMetadataToItemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMetadataToItemResponse, error) {
	rsp, err := c.AddMetadataToItem(ctx, itemname, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMetadataToItemResponse(rsp)
}

// GetItemState1WithResponse request returning *GetItemState1Response
func (c *ClientWithResponses) GetItemState1WithResponse(ctx context.Context, itemname string, reqEditors ...RequestEditorFn) (*GetItemState1Response, error) {
	rsp, err := c.GetItemState1(ctx, itemname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemState1Response(rsp)
}

// UpdateItemStateWithBodyWithResponse request with arbitrary body returning *UpdateItemStateResponse
func (c *ClientWithResponses) UpdateItemStateWithBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error) {
	rsp, err := c.UpdateItemStateWithBody(ctx, itemname, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemStateResponse(rsp)
}

func (c *ClientWithResponses) UpdateItemStateWithTextBodyWithResponse(ctx context.Context, itemname string, params *UpdateItemStateParams, body UpdateItemStateTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateItemStateResponse, error) {
	rsp, err := c.UpdateItemStateWithTextBody(ctx, itemname, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateItemStateResponse(rsp)
}

// RemoveTagFromItemWithResponse request returning *RemoveTagFromItemResponse
func (c *ClientWithResponses) RemoveTagFromItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*RemoveTagFromItemResponse, error) {
	rsp, err := c.RemoveTagFromItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTagFromItemResponse(rsp)
}

// AddTagToItemWithResponse request returning *AddTagToItemResponse
func (c *ClientWithResponses) AddTagToItemWithResponse(ctx context.Context, itemname string, tag string, reqEditors ...RequestEditorFn) (*AddTagToItemResponse, error) {
	rsp, err := c.AddTagToItem(ctx, itemname, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTagToItemResponse(rsp)
}

// GetItemLinksWithResponse request returning *GetItemLinksResponse
func (c *ClientWithResponses) GetItemLinksWithResponse(ctx context.Context, params *GetItemLinksParams, reqEditors ...RequestEditorFn) (*GetItemLinksResponse, error) {
	rsp, err := c.GetItemLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinksResponse(rsp)
}

// GetOrphanLinksWithResponse request returning *GetOrphanLinksResponse
func (c *ClientWithResponses) GetOrphanLinksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOrphanLinksResponse, error) {
	rsp, err := c.GetOrphanLinks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrphanLinksResponse(rsp)
}

// PurgeDatabase1WithResponse request returning *PurgeDatabase1Response
func (c *ClientWithResponses) PurgeDatabase1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PurgeDatabase1Response, error) {
	rsp, err := c.PurgeDatabase1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeDatabase1Response(rsp)
}

// UnlinkItemFromChannelWithResponse request returning *UnlinkItemFromChannelResponse
func (c *ClientWithResponses) UnlinkItemFromChannelWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*UnlinkItemFromChannelResponse, error) {
	rsp, err := c.UnlinkItemFromChannel(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnlinkItemFromChannelResponse(rsp)
}

// GetItemLinkWithResponse request returning *GetItemLinkResponse
func (c *ClientWithResponses) GetItemLinkWithResponse(ctx context.Context, itemName string, channelUID string, reqEditors ...RequestEditorFn) (*GetItemLinkResponse, error) {
	rsp, err := c.GetItemLink(ctx, itemName, channelUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemLinkResponse(rsp)
}

// LinkItemToChannelWithBodyWithResponse request with arbitrary body returning *LinkItemToChannelResponse
func (c *ClientWithResponses) LinkItemToChannelWithBodyWithResponse(ctx context.Context, itemName string, channelUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error) {
	rsp, err := c.LinkItemToChannelWithBody(ctx, itemName, channelUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkItemToChannelResponse(rsp)
}

func (c *ClientWithResponses) LinkItemToChannelWithResponse(ctx context.Context, itemName string, channelUID string, body LinkItemToChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkItemToChannelResponse, error) {
	rsp, err := c.LinkItemToChannel(ctx, itemName, channelUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkItemToChannelResponse(rsp)
}

// RemoveAllLinksForObjectWithResponse request returning *RemoveAllLinksForObjectResponse
func (c *ClientWithResponses) RemoveAllLinksForObjectWithResponse(ctx context.Context, object string, reqEditors ...RequestEditorFn) (*RemoveAllLinksForObjectResponse, error) {
	rsp, err := c.RemoveAllLinksForObject(ctx, object, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveAllLinksForObjectResponse(rsp)
}

// GetLogger1WithResponse request returning *GetLogger1Response
func (c *ClientWithResponses) GetLogger1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogger1Response, error) {
	rsp, err := c.GetLogger1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogger1Response(rsp)
}

// RemoveLoggerWithResponse request returning *RemoveLoggerResponse
func (c *ClientWithResponses) RemoveLoggerWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*RemoveLoggerResponse, error) {
	rsp, err := c.RemoveLogger(ctx, loggerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveLoggerResponse(rsp)
}

// GetLoggerWithResponse request returning *GetLoggerResponse
func (c *ClientWithResponses) GetLoggerWithResponse(ctx context.Context, loggerName string, reqEditors ...RequestEditorFn) (*GetLoggerResponse, error) {
	rsp, err := c.GetLogger(ctx, loggerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggerResponse(rsp)
}

// PutLoggerWithBodyWithResponse request with arbitrary body returning *PutLoggerResponse
func (c *ClientWithResponses) PutLoggerWithBodyWithResponse(ctx context.Context, loggerName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutLoggerResponse, error) {
	rsp, err := c.PutLoggerWithBody(ctx, loggerName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLoggerResponse(rsp)
}

func (c *ClientWithResponses) PutLoggerWithResponse(ctx context.Context, loggerName string, body PutLoggerJSONRequestBody, reqEditors ...RequestEditorFn) (*PutLoggerResponse, error) {
	rsp, err := c.PutLogger(ctx, loggerName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutLoggerResponse(rsp)
}

// GetModuleTypesWithResponse request returning *GetModuleTypesResponse
func (c *ClientWithResponses) GetModuleTypesWithResponse(ctx context.Context, params *GetModuleTypesParams, reqEditors ...RequestEditorFn) (*GetModuleTypesResponse, error) {
	rsp, err := c.GetModuleTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypesResponse(rsp)
}

// GetModuleTypeByIdWithResponse request returning *GetModuleTypeByIdResponse
func (c *ClientWithResponses) GetModuleTypeByIdWithResponse(ctx context.Context, moduleTypeUID string, params *GetModuleTypeByIdParams, reqEditors ...RequestEditorFn) (*GetModuleTypeByIdResponse, error) {
	rsp, err := c.GetModuleTypeById(ctx, moduleTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModuleTypeByIdResponse(rsp)
}

// GetPersistenceServicesWithResponse request returning *GetPersistenceServicesResponse
func (c *ClientWithResponses) GetPersistenceServicesWithResponse(ctx context.Context, params *GetPersistenceServicesParams, reqEditors ...RequestEditorFn) (*GetPersistenceServicesResponse, error) {
	rsp, err := c.GetPersistenceServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceServicesResponse(rsp)
}

// GetItemsForPersistenceServiceWithResponse request returning *GetItemsForPersistenceServiceResponse
func (c *ClientWithResponses) GetItemsForPersistenceServiceWithResponse(ctx context.Context, params *GetItemsForPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemsForPersistenceServiceResponse, error) {
	rsp, err := c.GetItemsForPersistenceService(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsForPersistenceServiceResponse(rsp)
}

// DeleteItemFromPersistenceServiceWithResponse request returning *DeleteItemFromPersistenceServiceResponse
func (c *ClientWithResponses) DeleteItemFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *DeleteItemFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*DeleteItemFromPersistenceServiceResponse, error) {
	rsp, err := c.DeleteItemFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteItemFromPersistenceServiceResponse(rsp)
}

// GetItemDataFromPersistenceServiceWithResponse request returning *GetItemDataFromPersistenceServiceResponse
func (c *ClientWithResponses) GetItemDataFromPersistenceServiceWithResponse(ctx context.Context, itemname string, params *GetItemDataFromPersistenceServiceParams, reqEditors ...RequestEditorFn) (*GetItemDataFromPersistenceServiceResponse, error) {
	rsp, err := c.GetItemDataFromPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemDataFromPersistenceServiceResponse(rsp)
}

// StoreItemDataInPersistenceServiceWithResponse request returning *StoreItemDataInPersistenceServiceResponse
func (c *ClientWithResponses) StoreItemDataInPersistenceServiceWithResponse(ctx context.Context, itemname string, params *StoreItemDataInPersistenceServiceParams, reqEditors ...RequestEditorFn) (*StoreItemDataInPersistenceServiceResponse, error) {
	rsp, err := c.StoreItemDataInPersistenceService(ctx, itemname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreItemDataInPersistenceServiceResponse(rsp)
}

// DeletePersistenceServiceConfigurationWithResponse request returning *DeletePersistenceServiceConfigurationResponse
func (c *ClientWithResponses) DeletePersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeletePersistenceServiceConfigurationResponse, error) {
	rsp, err := c.DeletePersistenceServiceConfiguration(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePersistenceServiceConfigurationResponse(rsp)
}

// GetPersistenceServiceConfigurationWithResponse request returning *GetPersistenceServiceConfigurationResponse
func (c *ClientWithResponses) GetPersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetPersistenceServiceConfigurationResponse, error) {
	rsp, err := c.GetPersistenceServiceConfiguration(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersistenceServiceConfigurationResponse(rsp)
}

// PutPersistenceServiceConfigurationWithBodyWithResponse request with arbitrary body returning *PutPersistenceServiceConfigurationResponse
func (c *ClientWithResponses) PutPersistenceServiceConfigurationWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPersistenceServiceConfigurationResponse, error) {
	rsp, err := c.PutPersistenceServiceConfigurationWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPersistenceServiceConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PutPersistenceServiceConfigurationWithResponse(ctx context.Context, serviceId string, body PutPersistenceServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPersistenceServiceConfigurationResponse, error) {
	rsp, err := c.PutPersistenceServiceConfiguration(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPersistenceServiceConfigurationResponse(rsp)
}

// GetProfileTypesWithResponse request returning *GetProfileTypesResponse
func (c *ClientWithResponses) GetProfileTypesWithResponse(ctx context.Context, params *GetProfileTypesParams, reqEditors ...RequestEditorFn) (*GetProfileTypesResponse, error) {
	rsp, err := c.GetProfileTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileTypesResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// GetScheduleRuleSimulationsWithResponse request returning *GetScheduleRuleSimulationsResponse
func (c *ClientWithResponses) GetScheduleRuleSimulationsWithResponse(ctx context.Context, params *GetScheduleRuleSimulationsParams, reqEditors ...RequestEditorFn) (*GetScheduleRuleSimulationsResponse, error) {
	rsp, err := c.GetScheduleRuleSimulations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleRuleSimulationsResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleByIdWithResponse request returning *GetRuleByIdResponse
func (c *ClientWithResponses) GetRuleByIdWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleByIdResponse, error) {
	rsp, err := c.GetRuleById(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleByIdResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, ruleUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// GetRuleActionsWithResponse request returning *GetRuleActionsResponse
func (c *ClientWithResponses) GetRuleActionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleActionsResponse, error) {
	rsp, err := c.GetRuleActions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleActionsResponse(rsp)
}

// GetRuleConditionsWithResponse request returning *GetRuleConditionsResponse
func (c *ClientWithResponses) GetRuleConditionsWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConditionsResponse, error) {
	rsp, err := c.GetRuleConditions(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConditionsResponse(rsp)
}

// GetRuleConfigurationWithResponse request returning *GetRuleConfigurationResponse
func (c *ClientWithResponses) GetRuleConfigurationWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleConfigurationResponse, error) {
	rsp, err := c.GetRuleConfiguration(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleConfigurationResponse(rsp)
}

// UpdateRuleConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateRuleConfigurationResponse
func (c *ClientWithResponses) UpdateRuleConfigurationWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfigurationWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleConfigurationWithResponse(ctx context.Context, ruleUID string, body UpdateRuleConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleConfigurationResponse, error) {
	rsp, err := c.UpdateRuleConfiguration(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleConfigurationResponse(rsp)
}

// EnableRuleWithBodyWithResponse request with arbitrary body returning *EnableRuleResponse
func (c *ClientWithResponses) EnableRuleWithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error) {
	rsp, err := c.EnableRuleWithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableRuleResponse(rsp)
}

func (c *ClientWithResponses) EnableRuleWithTextBodyWithResponse(ctx context.Context, ruleUID string, body EnableRuleTextRequestBody, reqEditors ...RequestEditorFn) (*EnableRuleResponse, error) {
	rsp, err := c.EnableRuleWithTextBody(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableRuleResponse(rsp)
}

// RunRuleNow1WithBodyWithResponse request with arbitrary body returning *RunRuleNow1Response
func (c *ClientWithResponses) RunRuleNow1WithBodyWithResponse(ctx context.Context, ruleUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunRuleNow1Response, error) {
	rsp, err := c.RunRuleNow1WithBody(ctx, ruleUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRuleNow1Response(rsp)
}

func (c *ClientWithResponses) RunRuleNow1WithResponse(ctx context.Context, ruleUID string, body RunRuleNow1JSONRequestBody, reqEditors ...RequestEditorFn) (*RunRuleNow1Response, error) {
	rsp, err := c.RunRuleNow1(ctx, ruleUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunRuleNow1Response(rsp)
}

// GetRuleTriggersWithResponse request returning *GetRuleTriggersResponse
func (c *ClientWithResponses) GetRuleTriggersWithResponse(ctx context.Context, ruleUID string, reqEditors ...RequestEditorFn) (*GetRuleTriggersResponse, error) {
	rsp, err := c.GetRuleTriggers(ctx, ruleUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleTriggersResponse(rsp)
}

// GetRuleModuleByIdWithResponse request returning *GetRuleModuleByIdResponse
func (c *ClientWithResponses) GetRuleModuleByIdWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleByIdResponse, error) {
	rsp, err := c.GetRuleModuleById(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleByIdResponse(rsp)
}

// GetRuleModuleConfigWithResponse request returning *GetRuleModuleConfigResponse
func (c *ClientWithResponses) GetRuleModuleConfigWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigResponse, error) {
	rsp, err := c.GetRuleModuleConfig(ctx, ruleUID, moduleCategory, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigResponse(rsp)
}

// GetRuleModuleConfigParameterWithResponse request returning *GetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) GetRuleModuleConfigParameterWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, reqEditors ...RequestEditorFn) (*GetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.GetRuleModuleConfigParameter(ctx, ruleUID, moduleCategory, id, param, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleModuleConfigParameterResponse(rsp)
}

// SetRuleModuleConfigParameterWithBodyWithResponse request with arbitrary body returning *SetRuleModuleConfigParameterResponse
func (c *ClientWithResponses) SetRuleModuleConfigParameterWithBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.SetRuleModuleConfigParameterWithBody(ctx, ruleUID, moduleCategory, id, param, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRuleModuleConfigParameterResponse(rsp)
}

func (c *ClientWithResponses) SetRuleModuleConfigParameterWithTextBodyWithResponse(ctx context.Context, ruleUID string, moduleCategory string, id string, param string, body SetRuleModuleConfigParameterTextRequestBody, reqEditors ...RequestEditorFn) (*SetRuleModuleConfigParameterResponse, error) {
	rsp, err := c.SetRuleModuleConfigParameterWithTextBody(ctx, ruleUID, moduleCategory, id, param, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRuleModuleConfigParameterResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// GetServicesByIdWithResponse request returning *GetServicesByIdResponse
func (c *ClientWithResponses) GetServicesByIdWithResponse(ctx context.Context, serviceId string, params *GetServicesByIdParams, reqEditors ...RequestEditorFn) (*GetServicesByIdResponse, error) {
	rsp, err := c.GetServicesById(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesByIdResponse(rsp)
}

// DeleteServiceConfigWithResponse request returning *DeleteServiceConfigResponse
func (c *ClientWithResponses) DeleteServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*DeleteServiceConfigResponse, error) {
	rsp, err := c.DeleteServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceConfigResponse(rsp)
}

// GetServiceConfigWithResponse request returning *GetServiceConfigResponse
func (c *ClientWithResponses) GetServiceConfigWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceConfigResponse, error) {
	rsp, err := c.GetServiceConfig(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceConfigResponse(rsp)
}

// UpdateServiceConfigWithBodyWithResponse request with arbitrary body returning *UpdateServiceConfigResponse
func (c *ClientWithResponses) UpdateServiceConfigWithBodyWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfigWithBody(ctx, serviceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceConfigWithResponse(ctx context.Context, serviceId string, params *UpdateServiceConfigParams, body UpdateServiceConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceConfigResponse, error) {
	rsp, err := c.UpdateServiceConfig(ctx, serviceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceConfigResponse(rsp)
}

// GetServiceContextWithResponse request returning *GetServiceContextResponse
func (c *ClientWithResponses) GetServiceContextWithResponse(ctx context.Context, serviceId string, params *GetServiceContextParams, reqEditors ...RequestEditorFn) (*GetServiceContextResponse, error) {
	rsp, err := c.GetServiceContext(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceContextResponse(rsp)
}

// GetSitemapsWithResponse request returning *GetSitemapsResponse
func (c *ClientWithResponses) GetSitemapsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSitemapsResponse, error) {
	rsp, err := c.GetSitemaps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapsResponse(rsp)
}

// CreateSitemapEventSubscriptionWithResponse request returning *CreateSitemapEventSubscriptionResponse
func (c *ClientWithResponses) CreateSitemapEventSubscriptionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateSitemapEventSubscriptionResponse, error) {
	rsp, err := c.CreateSitemapEventSubscription(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSitemapEventSubscriptionResponse(rsp)
}

// GetSitemapEvents1WithResponse request returning *GetSitemapEvents1Response
func (c *ClientWithResponses) GetSitemapEvents1WithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEvents1Params, reqEditors ...RequestEditorFn) (*GetSitemapEvents1Response, error) {
	rsp, err := c.GetSitemapEvents1(ctx, subscriptionid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapEvents1Response(rsp)
}

// GetSitemapEventsWithResponse request returning *GetSitemapEventsResponse
func (c *ClientWithResponses) GetSitemapEventsWithResponse(ctx context.Context, subscriptionid string, params *GetSitemapEventsParams, reqEditors ...RequestEditorFn) (*GetSitemapEventsResponse, error) {
	rsp, err := c.GetSitemapEvents(ctx, subscriptionid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapEventsResponse(rsp)
}

// GetSitemapByNameWithResponse request returning *GetSitemapByNameResponse
func (c *ClientWithResponses) GetSitemapByNameWithResponse(ctx context.Context, sitemapname string, params *GetSitemapByNameParams, reqEditors ...RequestEditorFn) (*GetSitemapByNameResponse, error) {
	rsp, err := c.GetSitemapByName(ctx, sitemapname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitemapByNameResponse(rsp)
}

// PollDataForSitemapWithResponse request returning *PollDataForSitemapResponse
func (c *ClientWithResponses) PollDataForSitemapWithResponse(ctx context.Context, sitemapname string, params *PollDataForSitemapParams, reqEditors ...RequestEditorFn) (*PollDataForSitemapResponse, error) {
	rsp, err := c.PollDataForSitemap(ctx, sitemapname, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollDataForSitemapResponse(rsp)
}

// PollDataForPageWithResponse request returning *PollDataForPageResponse
func (c *ClientWithResponses) PollDataForPageWithResponse(ctx context.Context, sitemapname string, pageid string, params *PollDataForPageParams, reqEditors ...RequestEditorFn) (*PollDataForPageResponse, error) {
	rsp, err := c.PollDataForPage(ctx, sitemapname, pageid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePollDataForPageResponse(rsp)
}

// GetSystemInformationWithResponse request returning *GetSystemInformationResponse
func (c *ClientWithResponses) GetSystemInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemInformationResponse, error) {
	rsp, err := c.GetSystemInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemInformationResponse(rsp)
}

// GetUoMInformationWithResponse request returning *GetUoMInformationResponse
func (c *ClientWithResponses) GetUoMInformationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUoMInformationResponse, error) {
	rsp, err := c.GetUoMInformation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUoMInformationResponse(rsp)
}

// GetSemanticTagsWithResponse request returning *GetSemanticTagsResponse
func (c *ClientWithResponses) GetSemanticTagsWithResponse(ctx context.Context, params *GetSemanticTagsParams, reqEditors ...RequestEditorFn) (*GetSemanticTagsResponse, error) {
	rsp, err := c.GetSemanticTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSemanticTagsResponse(rsp)
}

// CreateSemanticTagWithBodyWithResponse request with arbitrary body returning *CreateSemanticTagResponse
func (c *ClientWithResponses) CreateSemanticTagWithBodyWithResponse(ctx context.Context, params *CreateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSemanticTagResponse, error) {
	rsp, err := c.CreateSemanticTagWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSemanticTagResponse(rsp)
}

func (c *ClientWithResponses) CreateSemanticTagWithResponse(ctx context.Context, params *CreateSemanticTagParams, body CreateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSemanticTagResponse, error) {
	rsp, err := c.CreateSemanticTag(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSemanticTagResponse(rsp)
}

// RemoveSemanticTagWithResponse request returning *RemoveSemanticTagResponse
func (c *ClientWithResponses) RemoveSemanticTagWithResponse(ctx context.Context, tagId string, params *RemoveSemanticTagParams, reqEditors ...RequestEditorFn) (*RemoveSemanticTagResponse, error) {
	rsp, err := c.RemoveSemanticTag(ctx, tagId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSemanticTagResponse(rsp)
}

// GetSemanticTagAndSubTagsWithResponse request returning *GetSemanticTagAndSubTagsResponse
func (c *ClientWithResponses) GetSemanticTagAndSubTagsWithResponse(ctx context.Context, tagId string, params *GetSemanticTagAndSubTagsParams, reqEditors ...RequestEditorFn) (*GetSemanticTagAndSubTagsResponse, error) {
	rsp, err := c.GetSemanticTagAndSubTags(ctx, tagId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSemanticTagAndSubTagsResponse(rsp)
}

// UpdateSemanticTagWithBodyWithResponse request with arbitrary body returning *UpdateSemanticTagResponse
func (c *ClientWithResponses) UpdateSemanticTagWithBodyWithResponse(ctx context.Context, tagId string, params *UpdateSemanticTagParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSemanticTagResponse, error) {
	rsp, err := c.UpdateSemanticTagWithBody(ctx, tagId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSemanticTagResponse(rsp)
}

func (c *ClientWithResponses) UpdateSemanticTagWithResponse(ctx context.Context, tagId string, params *UpdateSemanticTagParams, body UpdateSemanticTagJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSemanticTagResponse, error) {
	rsp, err := c.UpdateSemanticTag(ctx, tagId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSemanticTagResponse(rsp)
}

// GetTemplatesWithResponse request returning *GetTemplatesResponse
func (c *ClientWithResponses) GetTemplatesWithResponse(ctx context.Context, params *GetTemplatesParams, reqEditors ...RequestEditorFn) (*GetTemplatesResponse, error) {
	rsp, err := c.GetTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplatesResponse(rsp)
}

// GetTemplateByIdWithResponse request returning *GetTemplateByIdResponse
func (c *ClientWithResponses) GetTemplateByIdWithResponse(ctx context.Context, templateUID string, params *GetTemplateByIdParams, reqEditors ...RequestEditorFn) (*GetTemplateByIdResponse, error) {
	rsp, err := c.GetTemplateById(ctx, templateUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTemplateByIdResponse(rsp)
}

// GetThingTypesWithResponse request returning *GetThingTypesResponse
func (c *ClientWithResponses) GetThingTypesWithResponse(ctx context.Context, params *GetThingTypesParams, reqEditors ...RequestEditorFn) (*GetThingTypesResponse, error) {
	rsp, err := c.GetThingTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypesResponse(rsp)
}

// GetThingTypeByIdWithResponse request returning *GetThingTypeByIdResponse
func (c *ClientWithResponses) GetThingTypeByIdWithResponse(ctx context.Context, thingTypeUID string, params *GetThingTypeByIdParams, reqEditors ...RequestEditorFn) (*GetThingTypeByIdResponse, error) {
	rsp, err := c.GetThingTypeById(ctx, thingTypeUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingTypeByIdResponse(rsp)
}

// GetThingsWithResponse request returning *GetThingsResponse
func (c *ClientWithResponses) GetThingsWithResponse(ctx context.Context, params *GetThingsParams, reqEditors ...RequestEditorFn) (*GetThingsResponse, error) {
	rsp, err := c.GetThings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingsResponse(rsp)
}

// CreateThingInRegistryWithBodyWithResponse request with arbitrary body returning *CreateThingInRegistryResponse
func (c *ClientWithResponses) CreateThingInRegistryWithBodyWithResponse(ctx context.Context, params *CreateThingInRegistryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

func (c *ClientWithResponses) CreateThingInRegistryWithResponse(ctx context.Context, params *CreateThingInRegistryParams, body CreateThingInRegistryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThingInRegistryResponse, error) {
	rsp, err := c.CreateThingInRegistry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThingInRegistryResponse(rsp)
}

// RemoveThingByIdWithResponse request returning *RemoveThingByIdResponse
func (c *ClientWithResponses) RemoveThingByIdWithResponse(ctx context.Context, thingUID string, params *RemoveThingByIdParams, reqEditors ...RequestEditorFn) (*RemoveThingByIdResponse, error) {
	rsp, err := c.RemoveThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveThingByIdResponse(rsp)
}

// GetThingByIdWithResponse request returning *GetThingByIdResponse
func (c *ClientWithResponses) GetThingByIdWithResponse(ctx context.Context, thingUID string, params *GetThingByIdParams, reqEditors ...RequestEditorFn) (*GetThingByIdResponse, error) {
	rsp, err := c.GetThingById(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingByIdResponse(rsp)
}

// UpdateThingWithBodyWithResponse request with arbitrary body returning *UpdateThingResponse
func (c *ClientWithResponses) UpdateThingWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingWithResponse(ctx context.Context, thingUID string, params *UpdateThingParams, body UpdateThingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingResponse, error) {
	rsp, err := c.UpdateThing(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingResponse(rsp)
}

// UpdateThingConfigWithBodyWithResponse request with arbitrary body returning *UpdateThingConfigResponse
func (c *ClientWithResponses) UpdateThingConfigWithBodyWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfigWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateThingConfigWithResponse(ctx context.Context, thingUID string, params *UpdateThingConfigParams, body UpdateThingConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateThingConfigResponse, error) {
	rsp, err := c.UpdateThingConfig(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingConfigResponse(rsp)
}

// GetThingConfigStatusWithResponse request returning *GetThingConfigStatusResponse
func (c *ClientWithResponses) GetThingConfigStatusWithResponse(ctx context.Context, thingUID string, params *GetThingConfigStatusParams, reqEditors ...RequestEditorFn) (*GetThingConfigStatusResponse, error) {
	rsp, err := c.GetThingConfigStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingConfigStatusResponse(rsp)
}

// EnableThingWithBodyWithResponse request with arbitrary body returning *EnableThingResponse
func (c *ClientWithResponses) EnableThingWithBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableThingResponse, error) {
	rsp, err := c.EnableThingWithBody(ctx, thingUID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableThingResponse(rsp)
}

func (c *ClientWithResponses) EnableThingWithTextBodyWithResponse(ctx context.Context, thingUID string, params *EnableThingParams, body EnableThingTextRequestBody, reqEditors ...RequestEditorFn) (*EnableThingResponse, error) {
	rsp, err := c.EnableThingWithTextBody(ctx, thingUID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableThingResponse(rsp)
}

// GetThingFirmwareStatusWithResponse request returning *GetThingFirmwareStatusResponse
func (c *ClientWithResponses) GetThingFirmwareStatusWithResponse(ctx context.Context, thingUID string, params *GetThingFirmwareStatusParams, reqEditors ...RequestEditorFn) (*GetThingFirmwareStatusResponse, error) {
	rsp, err := c.GetThingFirmwareStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingFirmwareStatusResponse(rsp)
}

// UpdateThingFirmwareWithResponse request returning *UpdateThingFirmwareResponse
func (c *ClientWithResponses) UpdateThingFirmwareWithResponse(ctx context.Context, thingUID string, firmwareVersion string, params *UpdateThingFirmwareParams, reqEditors ...RequestEditorFn) (*UpdateThingFirmwareResponse, error) {
	rsp, err := c.UpdateThingFirmware(ctx, thingUID, firmwareVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateThingFirmwareResponse(rsp)
}

// GetAvailableFirmwaresForThingWithResponse request returning *GetAvailableFirmwaresForThingResponse
func (c *ClientWithResponses) GetAvailableFirmwaresForThingWithResponse(ctx context.Context, thingUID string, params *GetAvailableFirmwaresForThingParams, reqEditors ...RequestEditorFn) (*GetAvailableFirmwaresForThingResponse, error) {
	rsp, err := c.GetAvailableFirmwaresForThing(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableFirmwaresForThingResponse(rsp)
}

// GetThingStatusWithResponse request returning *GetThingStatusResponse
func (c *ClientWithResponses) GetThingStatusWithResponse(ctx context.Context, thingUID string, params *GetThingStatusParams, reqEditors ...RequestEditorFn) (*GetThingStatusResponse, error) {
	rsp, err := c.GetThingStatus(ctx, thingUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThingStatusResponse(rsp)
}

// GetTransformationsWithResponse request returning *GetTransformationsResponse
func (c *ClientWithResponses) GetTransformationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTransformationsResponse, error) {
	rsp, err := c.GetTransformations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransformationsResponse(rsp)
}

// GetTransformationServicesWithResponse request returning *GetTransformationServicesResponse
func (c *ClientWithResponses) GetTransformationServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTransformationServicesResponse, error) {
	rsp, err := c.GetTransformationServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransformationServicesResponse(rsp)
}

// DeleteTransformationWithResponse request returning *DeleteTransformationResponse
func (c *ClientWithResponses) DeleteTransformationWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteTransformationResponse, error) {
	rsp, err := c.DeleteTransformation(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransformationResponse(rsp)
}

// GetTransformationWithResponse request returning *GetTransformationResponse
func (c *ClientWithResponses) GetTransformationWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetTransformationResponse, error) {
	rsp, err := c.GetTransformation(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransformationResponse(rsp)
}

// PutTransformationWithBodyWithResponse request with arbitrary body returning *PutTransformationResponse
func (c *ClientWithResponses) PutTransformationWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTransformationResponse, error) {
	rsp, err := c.PutTransformationWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTransformationResponse(rsp)
}

func (c *ClientWithResponses) PutTransformationWithResponse(ctx context.Context, uid string, body PutTransformationJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTransformationResponse, error) {
	rsp, err := c.PutTransformation(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTransformationResponse(rsp)
}

// GetRegisteredUIComponentsInNamespaceWithResponse request returning *GetRegisteredUIComponentsInNamespaceResponse
func (c *ClientWithResponses) GetRegisteredUIComponentsInNamespaceWithResponse(ctx context.Context, namespace string, params *GetRegisteredUIComponentsInNamespaceParams, reqEditors ...RequestEditorFn) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	rsp, err := c.GetRegisteredUIComponentsInNamespace(ctx, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegisteredUIComponentsInNamespaceResponse(rsp)
}

// AddUIComponentToNamespaceWithBodyWithResponse request with arbitrary body returning *AddUIComponentToNamespaceResponse
func (c *ClientWithResponses) AddUIComponentToNamespaceWithBodyWithResponse(ctx context.Context, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error) {
	rsp, err := c.AddUIComponentToNamespaceWithBody(ctx, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUIComponentToNamespaceResponse(rsp)
}

func (c *ClientWithResponses) AddUIComponentToNamespaceWithResponse(ctx context.Context, namespace string, body AddUIComponentToNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUIComponentToNamespaceResponse, error) {
	rsp, err := c.AddUIComponentToNamespace(ctx, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUIComponentToNamespaceResponse(rsp)
}

// RemoveUIComponentFromNamespaceWithResponse request returning *RemoveUIComponentFromNamespaceResponse
func (c *ClientWithResponses) RemoveUIComponentFromNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*RemoveUIComponentFromNamespaceResponse, error) {
	rsp, err := c.RemoveUIComponentFromNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUIComponentFromNamespaceResponse(rsp)
}

// GetUIComponentInNamespaceWithResponse request returning *GetUIComponentInNamespaceResponse
func (c *ClientWithResponses) GetUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, reqEditors ...RequestEditorFn) (*GetUIComponentInNamespaceResponse, error) {
	rsp, err := c.GetUIComponentInNamespace(ctx, namespace, componentUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUIComponentInNamespaceResponse(rsp)
}

// UpdateUIComponentInNamespaceWithBodyWithResponse request with arbitrary body returning *UpdateUIComponentInNamespaceResponse
func (c *ClientWithResponses) UpdateUIComponentInNamespaceWithBodyWithResponse(ctx context.Context, namespace string, componentUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error) {
	rsp, err := c.UpdateUIComponentInNamespaceWithBody(ctx, namespace, componentUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUIComponentInNamespaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateUIComponentInNamespaceWithResponse(ctx context.Context, namespace string, componentUID string, body UpdateUIComponentInNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUIComponentInNamespaceResponse, error) {
	rsp, err := c.UpdateUIComponentInNamespace(ctx, namespace, componentUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUIComponentInNamespaceResponse(rsp)
}

// GetUITilesWithResponse request returning *GetUITilesResponse
func (c *ClientWithResponses) GetUITilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUITilesResponse, error) {
	rsp, err := c.GetUITiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUITilesResponse(rsp)
}

// GetUUIDWithResponse request returning *GetUUIDResponse
func (c *ClientWithResponses) GetUUIDWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUUIDResponse, error) {
	rsp, err := c.GetUUID(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUUIDResponse(rsp)
}

// GetDefaultVoiceWithResponse request returning *GetDefaultVoiceResponse
func (c *ClientWithResponses) GetDefaultVoiceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultVoiceResponse, error) {
	rsp, err := c.GetDefaultVoice(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultVoiceResponse(rsp)
}

// StartDialogWithResponse request returning *StartDialogResponse
func (c *ClientWithResponses) StartDialogWithResponse(ctx context.Context, params *StartDialogParams, reqEditors ...RequestEditorFn) (*StartDialogResponse, error) {
	rsp, err := c.StartDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartDialogResponse(rsp)
}

// StopDialogWithResponse request returning *StopDialogResponse
func (c *ClientWithResponses) StopDialogWithResponse(ctx context.Context, params *StopDialogParams, reqEditors ...RequestEditorFn) (*StopDialogResponse, error) {
	rsp, err := c.StopDialog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopDialogResponse(rsp)
}

// GetVoiceInterpretersWithResponse request returning *GetVoiceInterpretersResponse
func (c *ClientWithResponses) GetVoiceInterpretersWithResponse(ctx context.Context, params *GetVoiceInterpretersParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpretersResponse, error) {
	rsp, err := c.GetVoiceInterpreters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpretersResponse(rsp)
}

// InterpretTextByDefaultInterpreterWithBodyWithResponse request with arbitrary body returning *InterpretTextByDefaultInterpreterResponse
func (c *ClientWithResponses) InterpretTextByDefaultInterpreterWithBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error) {
	rsp, err := c.InterpretTextByDefaultInterpreterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextByDefaultInterpreterResponse(rsp)
}

func (c *ClientWithResponses) InterpretTextByDefaultInterpreterWithTextBodyWithResponse(ctx context.Context, params *InterpretTextByDefaultInterpreterParams, body InterpretTextByDefaultInterpreterTextRequestBody, reqEditors ...RequestEditorFn) (*InterpretTextByDefaultInterpreterResponse, error) {
	rsp, err := c.InterpretTextByDefaultInterpreterWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextByDefaultInterpreterResponse(rsp)
}

// InterpretTextWithBodyWithResponse request with arbitrary body returning *InterpretTextResponse
func (c *ClientWithResponses) InterpretTextWithBodyWithResponse(ctx context.Context, ids []string, params *InterpretTextParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error) {
	rsp, err := c.InterpretTextWithBody(ctx, ids, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextResponse(rsp)
}

func (c *ClientWithResponses) InterpretTextWithTextBodyWithResponse(ctx context.Context, ids []string, params *InterpretTextParams, body InterpretTextTextRequestBody, reqEditors ...RequestEditorFn) (*InterpretTextResponse, error) {
	rsp, err := c.InterpretTextWithTextBody(ctx, ids, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInterpretTextResponse(rsp)
}

// GetVoiceInterpreterByUIDWithResponse request returning *GetVoiceInterpreterByUIDResponse
func (c *ClientWithResponses) GetVoiceInterpreterByUIDWithResponse(ctx context.Context, id string, params *GetVoiceInterpreterByUIDParams, reqEditors ...RequestEditorFn) (*GetVoiceInterpreterByUIDResponse, error) {
	rsp, err := c.GetVoiceInterpreterByUID(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoiceInterpreterByUIDResponse(rsp)
}

// ListenAndAnswerWithResponse request returning *ListenAndAnswerResponse
func (c *ClientWithResponses) ListenAndAnswerWithResponse(ctx context.Context, params *ListenAndAnswerParams, reqEditors ...RequestEditorFn) (*ListenAndAnswerResponse, error) {
	rsp, err := c.ListenAndAnswer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenAndAnswerResponse(rsp)
}

// TextToSpeechWithBodyWithResponse request with arbitrary body returning *TextToSpeechResponse
func (c *ClientWithResponses) TextToSpeechWithBodyWithResponse(ctx context.Context, params *TextToSpeechParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error) {
	rsp, err := c.TextToSpeechWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTextToSpeechResponse(rsp)
}

func (c *ClientWithResponses) TextToSpeechWithTextBodyWithResponse(ctx context.Context, params *TextToSpeechParams, body TextToSpeechTextRequestBody, reqEditors ...RequestEditorFn) (*TextToSpeechResponse, error) {
	rsp, err := c.TextToSpeechWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTextToSpeechResponse(rsp)
}

// GetVoicesWithResponse request returning *GetVoicesResponse
func (c *ClientWithResponses) GetVoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVoicesResponse, error) {
	rsp, err := c.GetVoices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoicesResponse(rsp)
}

// ParseGetRootResponse parses an HTTP response from a GetRootWithResponse call
func ParseGetRootResponse(rsp *http.Response) (*GetRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAvailableActionsForThingResponse parses an HTTP response from a GetAvailableActionsForThingWithResponse call
func ParseGetAvailableActionsForThingResponse(rsp *http.Response) (*GetAvailableActionsForThingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableActionsForThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ThingActionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExecuteThingActionResponse parses an HTTP response from a ExecuteThingActionWithResponse call
func ParseExecuteThingActionResponse(rsp *http.Response) (*ExecuteThingActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteThingActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonsResponse parses an HTTP response from a GetAddonsWithResponse call
func ParseGetAddonsResponse(rsp *http.Response) (*GetAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonTypesResponse parses an HTTP response from a GetAddonTypesWithResponse call
func ParseGetAddonTypesResponse(rsp *http.Response) (*GetAddonTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddonType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSuggestedAddonsResponse parses an HTTP response from a GetSuggestedAddonsWithResponse call
func ParseGetSuggestedAddonsResponse(rsp *http.Response) (*GetSuggestedAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSuggestedAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonServicesResponse parses an HTTP response from a GetAddonServicesWithResponse call
func ParseGetAddonServicesResponse(rsp *http.Response) (*GetAddonServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AddonType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonByIdResponse parses an HTTP response from a GetAddonByIdWithResponse call
func ParseGetAddonByIdResponse(rsp *http.Response) (*GetAddonByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAddonConfigurationResponse parses an HTTP response from a GetAddonConfigurationWithResponse call
func ParseGetAddonConfigurationResponse(rsp *http.Response) (*GetAddonConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAddonConfigurationResponse parses an HTTP response from a UpdateAddonConfigurationWithResponse call
func ParseUpdateAddonConfigurationResponse(rsp *http.Response) (*UpdateAddonConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAddonConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallAddonByIdResponse parses an HTTP response from a InstallAddonByIdWithResponse call
func ParseInstallAddonByIdResponse(rsp *http.Response) (*InstallAddonByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallAddonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUninstallAddonResponse parses an HTTP response from a UninstallAddonWithResponse call
func ParseUninstallAddonResponse(rsp *http.Response) (*UninstallAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UninstallAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAudioDefaultSinkResponse parses an HTTP response from a GetAudioDefaultSinkWithResponse call
func ParseGetAudioDefaultSinkResponse(rsp *http.Response) (*GetAudioDefaultSinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioDefaultSourceResponse parses an HTTP response from a GetAudioDefaultSourceWithResponse call
func ParseGetAudioDefaultSourceResponse(rsp *http.Response) (*GetAudioDefaultSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioDefaultSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSinksResponse parses an HTTP response from a GetAudioSinksWithResponse call
func ParseGetAudioSinksResponse(rsp *http.Response) (*GetAudioSinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAudioSourcesResponse parses an HTTP response from a GetAudioSourcesWithResponse call
func ParseGetAudioSourcesResponse(rsp *http.Response) (*GetAudioSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAudioSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AudioSourceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiTokensResponse parses an HTTP response from a GetApiTokensWithResponse call
func ParseGetApiTokensResponse(rsp *http.Response) (*GetApiTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserApiTokenDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveApiTokenResponse parses an HTTP response from a RemoveApiTokenWithResponse call
func ParseRemoveApiTokenResponse(rsp *http.Response) (*RemoveApiTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveApiTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSessionResponse parses an HTTP response from a DeleteSessionWithResponse call
func ParseDeleteSessionResponse(rsp *http.Response) (*DeleteSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSessionsForCurrentUserResponse parses an HTTP response from a GetSessionsForCurrentUserWithResponse call
func ParseGetSessionsForCurrentUserResponse(rsp *http.Response) (*GetSessionsForCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionsForCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserSessionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponseDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypesResponse parses an HTTP response from a GetChannelTypesWithResponse call
func ParseGetChannelTypesResponse(rsp *http.Response) (*GetChannelTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTypeByUIDResponse parses an HTTP response from a GetChannelTypeByUIDWithResponse call
func ParseGetChannelTypeByUIDResponse(rsp *http.Response) (*GetChannelTypeByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelTypeByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLinkableItemTypesByChannelTypeUIDResponse parses an HTTP response from a GetLinkableItemTypesByChannelTypeUIDWithResponse call
func ParseGetLinkableItemTypesByChannelTypeUIDResponse(rsp *http.Response) (*GetLinkableItemTypesByChannelTypeUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkableItemTypesByChannelTypeUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionsResponse parses an HTTP response from a GetConfigDescriptionsWithResponse call
func ParseGetConfigDescriptionsResponse(rsp *http.Response) (*GetConfigDescriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigDescriptionByURIResponse parses an HTTP response from a GetConfigDescriptionByURIWithResponse call
func ParseGetConfigDescriptionByURIResponse(rsp *http.Response) (*GetConfigDescriptionByURIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigDescriptionByURIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigDescriptionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBindingsWithDiscoverySupportResponse parses an HTTP response from a GetBindingsWithDiscoverySupportWithResponse call
func ParseGetBindingsWithDiscoverySupportResponse(rsp *http.Response) (*GetBindingsWithDiscoverySupportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindingsWithDiscoverySupportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScanResponse parses an HTTP response from a ScanWithResponse call
func ParseScanResponse(rsp *http.Response) (*ScanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInitNewStateTackerResponse parses an HTTP response from a InitNewStateTackerWithResponse call
func ParseInitNewStateTackerResponse(rsp *http.Response) (*InitNewStateTackerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitNewStateTackerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemListForStateUpdatesResponse parses an HTTP response from a UpdateItemListForStateUpdatesWithResponse call
func ParseUpdateItemListForStateUpdatesResponse(rsp *http.Response) (*UpdateItemListForStateUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemListForStateUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGalleryWidgetListResponse parses an HTTP response from a GetGalleryWidgetListWithResponse call
func ParseGetGalleryWidgetListResponse(rsp *http.Response) (*GetGalleryWidgetListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGalleryWidgetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GalleryWidgetsListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGalleryWidgetsItemResponse parses an HTTP response from a GetGalleryWidgetsItemWithResponse call
func ParseGetGalleryWidgetsItemResponse(rsp *http.Response) (*GetGalleryWidgetsItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGalleryWidgetsItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GalleryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIconSetsResponse parses an HTTP response from a GetIconSetsWithResponse call
func ParseGetIconSetsResponse(rsp *http.Response) (*GetIconSetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIconSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IconSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDiscoveredInboxItemsResponse parses an HTTP response from a GetDiscoveredInboxItemsWithResponse call
func ParseGetDiscoveredInboxItemsResponse(rsp *http.Response) (*GetDiscoveredInboxItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscoveredInboxItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DiscoveryResultDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveItemFromInboxResponse parses an HTTP response from a RemoveItemFromInboxWithResponse call
func ParseRemoveItemFromInboxResponse(rsp *http.Response) (*RemoveItemFromInboxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromInboxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseApproveInboxItemByIdResponse parses an HTTP response from a ApproveInboxItemByIdWithResponse call
func ParseApproveInboxItemByIdResponse(rsp *http.Response) (*ApproveInboxItemByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveInboxItemByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFlagInboxItemAsIgnoredResponse parses an HTTP response from a FlagInboxItemAsIgnoredWithResponse call
func ParseFlagInboxItemAsIgnoredResponse(rsp *http.Response) (*FlagInboxItemAsIgnoredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FlagInboxItemAsIgnoredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveIgnoreFlagOnInboxItemResponse parses an HTTP response from a RemoveIgnoreFlagOnInboxItemWithResponse call
func ParseRemoveIgnoreFlagOnInboxItemResponse(rsp *http.Response) (*RemoveIgnoreFlagOnInboxItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveIgnoreFlagOnInboxItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemsResponse parses an HTTP response from a GetItemsWithResponse call
func ParseGetItemsResponse(rsp *http.Response) (*GetItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddOrUpdateItemsInRegistryResponse parses an HTTP response from a AddOrUpdateItemsInRegistryWithResponse call
func ParseAddOrUpdateItemsInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemsInRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemsInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePurgeDatabaseResponse parses an HTTP response from a PurgeDatabaseWithResponse call
func ParsePurgeDatabaseResponse(rsp *http.Response) (*PurgeDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveMemberFromGroupItemResponse parses an HTTP response from a RemoveMemberFromGroupItemWithResponse call
func ParseRemoveMemberFromGroupItemResponse(rsp *http.Response) (*RemoveMemberFromGroupItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMemberFromGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMemberToGroupItemResponse parses an HTTP response from a AddMemberToGroupItemWithResponse call
func ParseAddMemberToGroupItemResponse(rsp *http.Response) (*AddMemberToGroupItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMemberToGroupItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSemanticItemResponse parses an HTTP response from a GetSemanticItemWithResponse call
func ParseGetSemanticItemResponse(rsp *http.Response) (*GetSemanticItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSemanticItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveItemFromRegistryResponse parses an HTTP response from a RemoveItemFromRegistryWithResponse call
func ParseRemoveItemFromRegistryResponse(rsp *http.Response) (*RemoveItemFromRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveItemFromRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemByNameResponse parses an HTTP response from a GetItemByNameWithResponse call
func ParseGetItemByNameResponse(rsp *http.Response) (*GetItemByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedItemDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendItemCommandResponse parses an HTTP response from a SendItemCommandWithResponse call
func ParseSendItemCommandResponse(rsp *http.Response) (*SendItemCommandResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendItemCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOrUpdateItemInRegistryResponse parses an HTTP response from a AddOrUpdateItemInRegistryWithResponse call
func ParseAddOrUpdateItemInRegistryResponse(rsp *http.Response) (*AddOrUpdateItemInRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrUpdateItemInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemNamespacesResponse parses an HTTP response from a GetItemNamespacesWithResponse call
func ParseGetItemNamespacesResponse(rsp *http.Response) (*GetItemNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveMetadataFromItemResponse parses an HTTP response from a RemoveMetadataFromItemWithResponse call
func ParseRemoveMetadataFromItemResponse(rsp *http.Response) (*RemoveMetadataFromItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMetadataFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddMetadataToItemResponse parses an HTTP response from a AddMetadataToItemWithResponse call
func ParseAddMetadataToItemResponse(rsp *http.Response) (*AddMetadataToItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMetadataToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemState1Response parses an HTTP response from a GetItemState1WithResponse call
func ParseGetItemState1Response(rsp *http.Response) (*GetItemState1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemState1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateItemStateResponse parses an HTTP response from a UpdateItemStateWithResponse call
func ParseUpdateItemStateResponse(rsp *http.Response) (*UpdateItemStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateItemStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveTagFromItemResponse parses an HTTP response from a RemoveTagFromItemWithResponse call
func ParseRemoveTagFromItemResponse(rsp *http.Response) (*RemoveTagFromItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTagFromItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddTagToItemResponse parses an HTTP response from a AddTagToItemWithResponse call
func ParseAddTagToItemResponse(rsp *http.Response) (*AddTagToItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTagToItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinksResponse parses an HTTP response from a GetItemLinksWithResponse call
func ParseGetItemLinksResponse(rsp *http.Response) (*GetItemLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedItemChannelLinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrphanLinksResponse parses an HTTP response from a GetOrphanLinksWithResponse call
func ParseGetOrphanLinksResponse(rsp *http.Response) (*GetOrphanLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrphanLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePurgeDatabase1Response parses an HTTP response from a PurgeDatabase1WithResponse call
func ParsePurgeDatabase1Response(rsp *http.Response) (*PurgeDatabase1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeDatabase1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnlinkItemFromChannelResponse parses an HTTP response from a UnlinkItemFromChannelWithResponse call
func ParseUnlinkItemFromChannelResponse(rsp *http.Response) (*UnlinkItemFromChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnlinkItemFromChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetItemLinkResponse parses an HTTP response from a GetItemLinkWithResponse call
func ParseGetItemLinkResponse(rsp *http.Response) (*GetItemLinkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedItemChannelLinkDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkItemToChannelResponse parses an HTTP response from a LinkItemToChannelWithResponse call
func ParseLinkItemToChannelResponse(rsp *http.Response) (*LinkItemToChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkItemToChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveAllLinksForObjectResponse parses an HTTP response from a RemoveAllLinksForObjectWithResponse call
func ParseRemoveAllLinksForObjectResponse(rsp *http.Response) (*RemoveAllLinksForObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveAllLinksForObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLogger1Response parses an HTTP response from a GetLogger1WithResponse call
func ParseGetLogger1Response(rsp *http.Response) (*GetLogger1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogger1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoggerBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveLoggerResponse parses an HTTP response from a RemoveLoggerWithResponse call
func ParseRemoveLoggerResponse(rsp *http.Response) (*RemoveLoggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveLoggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLoggerResponse parses an HTTP response from a GetLoggerWithResponse call
func ParseGetLoggerResponse(rsp *http.Response) (*GetLoggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoggerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutLoggerResponse parses an HTTP response from a PutLoggerWithResponse call
func ParsePutLoggerResponse(rsp *http.Response) (*PutLoggerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutLoggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModuleTypesResponse parses an HTTP response from a GetModuleTypesWithResponse call
func ParseGetModuleTypesResponse(rsp *http.Response) (*GetModuleTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModuleTypeByIdResponse parses an HTTP response from a GetModuleTypeByIdWithResponse call
func ParseGetModuleTypeByIdResponse(rsp *http.Response) (*GetModuleTypeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModuleTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersistenceServicesResponse parses an HTTP response from a GetPersistenceServicesWithResponse call
func ParseGetPersistenceServicesResponse(rsp *http.Response) (*GetPersistenceServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemsForPersistenceServiceResponse parses an HTTP response from a GetItemsForPersistenceServiceWithResponse call
func ParseGetItemsForPersistenceServiceResponse(rsp *http.Response) (*GetItemsForPersistenceServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsForPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PersistenceItemInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteItemFromPersistenceServiceResponse parses an HTTP response from a DeleteItemFromPersistenceServiceWithResponse call
func ParseDeleteItemFromPersistenceServiceResponse(rsp *http.Response) (*DeleteItemFromPersistenceServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteItemFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetItemDataFromPersistenceServiceResponse parses an HTTP response from a GetItemDataFromPersistenceServiceWithResponse call
func ParseGetItemDataFromPersistenceServiceResponse(rsp *http.Response) (*GetItemDataFromPersistenceServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemDataFromPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ItemHistoryDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreItemDataInPersistenceServiceResponse parses an HTTP response from a StoreItemDataInPersistenceServiceWithResponse call
func ParseStoreItemDataInPersistenceServiceResponse(rsp *http.Response) (*StoreItemDataInPersistenceServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreItemDataInPersistenceServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePersistenceServiceConfigurationResponse parses an HTTP response from a DeletePersistenceServiceConfigurationWithResponse call
func ParseDeletePersistenceServiceConfigurationResponse(rsp *http.Response) (*DeletePersistenceServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePersistenceServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPersistenceServiceConfigurationResponse parses an HTTP response from a GetPersistenceServiceConfigurationWithResponse call
func ParseGetPersistenceServiceConfigurationResponse(rsp *http.Response) (*GetPersistenceServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersistenceServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistenceServiceConfigurationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutPersistenceServiceConfigurationResponse parses an HTTP response from a PutPersistenceServiceConfigurationWithResponse call
func ParsePutPersistenceServiceConfigurationResponse(rsp *http.Response) (*PutPersistenceServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPersistenceServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistenceServiceConfigurationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProfileTypesResponse parses an HTTP response from a GetProfileTypesWithResponse call
func ParseGetProfileTypesResponse(rsp *http.Response) (*GetProfileTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProfileTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetScheduleRuleSimulationsResponse parses an HTTP response from a GetScheduleRuleSimulationsWithResponse call
func ParseGetScheduleRuleSimulationsResponse(rsp *http.Response) (*GetScheduleRuleSimulationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleRuleSimulationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RuleExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleByIdResponse parses an HTTP response from a GetRuleByIdWithResponse call
func ParseGetRuleByIdResponse(rsp *http.Response) (*GetRuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedRuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleActionsResponse parses an HTTP response from a GetRuleActionsWithResponse call
func ParseGetRuleActionsResponse(rsp *http.Response) (*GetRuleActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConditionsResponse parses an HTTP response from a GetRuleConditionsWithResponse call
func ParseGetRuleConditionsResponse(rsp *http.Response) (*GetRuleConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConditionDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleConfigurationResponse parses an HTTP response from a GetRuleConfigurationWithResponse call
func ParseGetRuleConfigurationResponse(rsp *http.Response) (*GetRuleConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleConfigurationResponse parses an HTTP response from a UpdateRuleConfigurationWithResponse call
func ParseUpdateRuleConfigurationResponse(rsp *http.Response) (*UpdateRuleConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnableRuleResponse parses an HTTP response from a EnableRuleWithResponse call
func ParseEnableRuleResponse(rsp *http.Response) (*EnableRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunRuleNow1Response parses an HTTP response from a RunRuleNow1WithResponse call
func ParseRunRuleNow1Response(rsp *http.Response) (*RunRuleNow1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunRuleNow1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleTriggersResponse parses an HTTP response from a GetRuleTriggersWithResponse call
func ParseGetRuleTriggersResponse(rsp *http.Response) (*GetRuleTriggersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleTriggersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TriggerDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleByIdResponse parses an HTTP response from a GetRuleModuleByIdWithResponse call
func ParseGetRuleModuleByIdResponse(rsp *http.Response) (*GetRuleModuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModuleDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigResponse parses an HTTP response from a GetRuleModuleConfigWithResponse call
func ParseGetRuleModuleConfigResponse(rsp *http.Response) (*GetRuleModuleConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRuleModuleConfigParameterResponse parses an HTTP response from a GetRuleModuleConfigParameterWithResponse call
func ParseGetRuleModuleConfigParameterResponse(rsp *http.Response) (*GetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetRuleModuleConfigParameterResponse parses an HTTP response from a SetRuleModuleConfigParameterWithResponse call
func ParseSetRuleModuleConfigParameterResponse(rsp *http.Response) (*SetRuleModuleConfigParameterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetRuleModuleConfigParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesByIdResponse parses an HTTP response from a GetServicesByIdWithResponse call
func ParseGetServicesByIdResponse(rsp *http.Response) (*GetServicesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceConfigResponse parses an HTTP response from a DeleteServiceConfigWithResponse call
func ParseDeleteServiceConfigResponse(rsp *http.Response) (*DeleteServiceConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceConfigResponse parses an HTTP response from a GetServiceConfigWithResponse call
func ParseGetServiceConfigResponse(rsp *http.Response) (*GetServiceConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceConfigResponse parses an HTTP response from a UpdateServiceConfigWithResponse call
func ParseUpdateServiceConfigResponse(rsp *http.Response) (*UpdateServiceConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceContextResponse parses an HTTP response from a GetServiceContextWithResponse call
func ParseGetServiceContextResponse(rsp *http.Response) (*GetServiceContextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigurableServiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSitemapsResponse parses an HTTP response from a GetSitemapsWithResponse call
func ParseGetSitemapsResponse(rsp *http.Response) (*GetSitemapsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSitemapEventSubscriptionResponse parses an HTTP response from a CreateSitemapEventSubscriptionWithResponse call
func ParseCreateSitemapEventSubscriptionResponse(rsp *http.Response) (*CreateSitemapEventSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSitemapEventSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapEvents1Response parses an HTTP response from a GetSitemapEvents1WithResponse call
func ParseGetSitemapEvents1Response(rsp *http.Response) (*GetSitemapEvents1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapEvents1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapEventsResponse parses an HTTP response from a GetSitemapEventsWithResponse call
func ParseGetSitemapEventsResponse(rsp *http.Response) (*GetSitemapEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSitemapByNameResponse parses an HTTP response from a GetSitemapByNameWithResponse call
func ParseGetSitemapByNameResponse(rsp *http.Response) (*GetSitemapByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitemapByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePollDataForSitemapResponse parses an HTTP response from a PollDataForSitemapWithResponse call
func ParsePollDataForSitemapResponse(rsp *http.Response) (*PollDataForSitemapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollDataForSitemapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SitemapDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePollDataForPageResponse parses an HTTP response from a PollDataForPageWithResponse call
func ParsePollDataForPageResponse(rsp *http.Response) (*PollDataForPageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PollDataForPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSystemInformationResponse parses an HTTP response from a GetSystemInformationWithResponse call
func ParseGetSystemInformationResponse(rsp *http.Response) (*GetSystemInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemInfoBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUoMInformationResponse parses an HTTP response from a GetUoMInformationWithResponse call
func ParseGetUoMInformationResponse(rsp *http.Response) (*GetUoMInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUoMInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UoMInfoBean
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSemanticTagsResponse parses an HTTP response from a GetSemanticTagsWithResponse call
func ParseGetSemanticTagsResponse(rsp *http.Response) (*GetSemanticTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSemanticTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedSemanticTagDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSemanticTagResponse parses an HTTP response from a CreateSemanticTagWithResponse call
func ParseCreateSemanticTagResponse(rsp *http.Response) (*CreateSemanticTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSemanticTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveSemanticTagResponse parses an HTTP response from a RemoveSemanticTagWithResponse call
func ParseRemoveSemanticTagResponse(rsp *http.Response) (*RemoveSemanticTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSemanticTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSemanticTagAndSubTagsResponse parses an HTTP response from a GetSemanticTagAndSubTagsWithResponse call
func ParseGetSemanticTagAndSubTagsResponse(rsp *http.Response) (*GetSemanticTagAndSubTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSemanticTagAndSubTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedSemanticTagDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSemanticTagResponse parses an HTTP response from a UpdateSemanticTagWithResponse call
func ParseUpdateSemanticTagResponse(rsp *http.Response) (*UpdateSemanticTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSemanticTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTemplatesResponse parses an HTTP response from a GetTemplatesWithResponse call
func ParseGetTemplatesResponse(rsp *http.Response) (*GetTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTemplateByIdResponse parses an HTTP response from a GetTemplateByIdWithResponse call
func ParseGetTemplateByIdResponse(rsp *http.Response) (*GetTemplateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTemplateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Template
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypesResponse parses an HTTP response from a GetThingTypesWithResponse call
func ParseGetThingTypesResponse(rsp *http.Response) (*GetThingTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []StrippedThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingTypeByIdResponse parses an HTTP response from a GetThingTypeByIdWithResponse call
func ParseGetThingTypeByIdResponse(rsp *http.Response) (*GetThingTypeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingTypeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingTypeDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingsResponse parses an HTTP response from a GetThingsWithResponse call
func ParseGetThingsResponse(rsp *http.Response) (*GetThingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateThingInRegistryResponse parses an HTTP response from a CreateThingInRegistryWithResponse call
func ParseCreateThingInRegistryResponse(rsp *http.Response) (*CreateThingInRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateThingInRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveThingByIdResponse parses an HTTP response from a RemoveThingByIdWithResponse call
func ParseRemoveThingByIdResponse(rsp *http.Response) (*RemoveThingByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingByIdResponse parses an HTTP response from a GetThingByIdWithResponse call
func ParseGetThingByIdResponse(rsp *http.Response) (*GetThingByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedThingDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateThingResponse parses an HTTP response from a UpdateThingWithResponse call
func ParseUpdateThingResponse(rsp *http.Response) (*UpdateThingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingConfigResponse parses an HTTP response from a UpdateThingConfigWithResponse call
func ParseUpdateThingConfigResponse(rsp *http.Response) (*UpdateThingConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingConfigStatusResponse parses an HTTP response from a GetThingConfigStatusWithResponse call
func ParseGetThingConfigStatusResponse(rsp *http.Response) (*GetThingConfigStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingConfigStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConfigStatusMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnableThingResponse parses an HTTP response from a EnableThingWithResponse call
func ParseEnableThingResponse(rsp *http.Response) (*EnableThingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetThingFirmwareStatusResponse parses an HTTP response from a GetThingFirmwareStatusWithResponse call
func ParseGetThingFirmwareStatusResponse(rsp *http.Response) (*GetThingFirmwareStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingFirmwareStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateThingFirmwareResponse parses an HTTP response from a UpdateThingFirmwareWithResponse call
func ParseUpdateThingFirmwareResponse(rsp *http.Response) (*UpdateThingFirmwareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateThingFirmwareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAvailableFirmwaresForThingResponse parses an HTTP response from a GetAvailableFirmwaresForThingWithResponse call
func ParseGetAvailableFirmwaresForThingResponse(rsp *http.Response) (*GetAvailableFirmwaresForThingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableFirmwaresForThingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FirmwareDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThingStatusResponse parses an HTTP response from a GetThingStatusWithResponse call
func ParseGetThingStatusResponse(rsp *http.Response) (*GetThingStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThingStatusInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransformationsResponse parses an HTTP response from a GetTransformationsWithResponse call
func ParseGetTransformationsResponse(rsp *http.Response) (*GetTransformationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransformationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TransformationDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransformationServicesResponse parses an HTTP response from a GetTransformationServicesWithResponse call
func ParseGetTransformationServicesResponse(rsp *http.Response) (*GetTransformationServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransformationServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTransformationResponse parses an HTTP response from a DeleteTransformationWithResponse call
func ParseDeleteTransformationResponse(rsp *http.Response) (*DeleteTransformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTransformationResponse parses an HTTP response from a GetTransformationWithResponse call
func ParseGetTransformationResponse(rsp *http.Response) (*GetTransformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutTransformationResponse parses an HTTP response from a PutTransformationWithResponse call
func ParsePutTransformationResponse(rsp *http.Response) (*PutTransformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTransformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRegisteredUIComponentsInNamespaceResponse parses an HTTP response from a GetRegisteredUIComponentsInNamespaceWithResponse call
func ParseGetRegisteredUIComponentsInNamespaceResponse(rsp *http.Response) (*GetRegisteredUIComponentsInNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegisteredUIComponentsInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUIComponentToNamespaceResponse parses an HTTP response from a AddUIComponentToNamespaceWithResponse call
func ParseAddUIComponentToNamespaceResponse(rsp *http.Response) (*AddUIComponentToNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUIComponentToNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUIComponentFromNamespaceResponse parses an HTTP response from a RemoveUIComponentFromNamespaceWithResponse call
func ParseRemoveUIComponentFromNamespaceResponse(rsp *http.Response) (*RemoveUIComponentFromNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUIComponentFromNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUIComponentInNamespaceResponse parses an HTTP response from a GetUIComponentInNamespaceWithResponse call
func ParseGetUIComponentInNamespaceResponse(rsp *http.Response) (*GetUIComponentInNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUIComponentInNamespaceResponse parses an HTTP response from a UpdateUIComponentInNamespaceWithResponse call
func ParseUpdateUIComponentInNamespaceResponse(rsp *http.Response) (*UpdateUIComponentInNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUIComponentInNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RootUIComponent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUITilesResponse parses an HTTP response from a GetUITilesWithResponse call
func ParseGetUITilesResponse(rsp *http.Response) (*GetUITilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUITilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TileDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUUIDResponse parses an HTTP response from a GetUUIDWithResponse call
func ParseGetUUIDResponse(rsp *http.Response) (*GetUUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDefaultVoiceResponse parses an HTTP response from a GetDefaultVoiceWithResponse call
func ParseGetDefaultVoiceResponse(rsp *http.Response) (*GetDefaultVoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultVoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartDialogResponse parses an HTTP response from a StartDialogWithResponse call
func ParseStartDialogResponse(rsp *http.Response) (*StartDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStopDialogResponse parses an HTTP response from a StopDialogWithResponse call
func ParseStopDialogResponse(rsp *http.Response) (*StopDialogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopDialogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoiceInterpretersResponse parses an HTTP response from a GetVoiceInterpretersWithResponse call
func ParseGetVoiceInterpretersResponse(rsp *http.Response) (*GetVoiceInterpretersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpretersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInterpretTextByDefaultInterpreterResponse parses an HTTP response from a InterpretTextByDefaultInterpreterWithResponse call
func ParseInterpretTextByDefaultInterpreterResponse(rsp *http.Response) (*InterpretTextByDefaultInterpreterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextByDefaultInterpreterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInterpretTextResponse parses an HTTP response from a InterpretTextWithResponse call
func ParseInterpretTextResponse(rsp *http.Response) (*InterpretTextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InterpretTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoiceInterpreterByUIDResponse parses an HTTP response from a GetVoiceInterpreterByUIDWithResponse call
func ParseGetVoiceInterpreterByUIDResponse(rsp *http.Response) (*GetVoiceInterpreterByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoiceInterpreterByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HumanLanguageInterpreterDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListenAndAnswerResponse parses an HTTP response from a ListenAndAnswerWithResponse call
func ParseListenAndAnswerResponse(rsp *http.Response) (*ListenAndAnswerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenAndAnswerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTextToSpeechResponse parses an HTTP response from a TextToSpeechWithResponse call
func ParseTextToSpeechResponse(rsp *http.Response) (*TextToSpeechResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TextToSpeechResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoicesResponse parses an HTTP response from a GetVoicesWithResponse call
func ParseGetVoicesResponse(rsp *http.Response) (*GetVoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VoiceDTO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
